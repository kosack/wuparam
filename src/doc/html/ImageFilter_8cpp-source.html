<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>wuparam: ImageFilter.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>ImageFilter.cpp</h1><div class="fragment"><pre>00001 
00020 <span class="preprocessor">#include &lt;iostream&gt;</span>
00021 <span class="preprocessor">#include &lt;iomanip&gt;</span>
00022 <span class="preprocessor">#include &lt;cmath&gt;</span>
00023 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
00024 <span class="preprocessor">#include &lt;valarray&gt;</span>
00025 <span class="preprocessor">#include &lt;vector&gt;</span>
00026 <span class="preprocessor">#include &lt;fstream&gt;</span>
00027 
00028 <span class="preprocessor">#include "ImageFilter.h"</span>
00029 
00030 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00031 
00032 
00033 <span class="keywordtype">void</span> hcut( <span class="keywordtype">double</span> *gpix_c );
00034 
00035 <span class="keywordtype">void</span> hcut_init( <span class="keywordtype">int</span> npix, <span class="keywordtype">double</span> *xpix_c,  <span class="keywordtype">double</span> *ypix_c, 
00036                 <span class="keywordtype">int</span> msub, <span class="keywordtype">double</span> afiltr, <span class="keywordtype">int</span> nc, <span class="keywordtype">double</span> spas);
00037 
00038 <span class="keywordtype">double</span> dinv(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> l );
00039 <span class="keywordtype">double</span> f0su3nul(<span class="keywordtype">double</span> xin, <span class="keywordtype">double</span> yin, <span class="keywordtype">int</span> n, <span class="keywordtype">double</span> af);
00040 <span class="keywordtype">void</span> dofltr0(<span class="keywordtype">double</span> s, <span class="keywordtype">int</span> n0, <span class="keywordtype">double</span> afil);
00041 <span class="keywordtype">double</span> f0pass(<span class="keywordtype">double</span> xin, <span class="keywordtype">double</span> yin, <span class="keywordtype">int</span> n, <span class="keywordtype">double</span> afil );
00042 <span class="keywordtype">void</span> doakl0(<span class="keywordtype">int</span> nn0, <span class="keywordtype">double</span> tfij[][201], <span class="keywordtype">int</span> &amp;k0re, <span class="keywordtype">int</span> &amp;k0im);
00043 <span class="keywordtype">void</span> derivs(<span class="keywordtype">int</span> n,<span class="keywordtype">int</span> kp,<span class="keywordtype">double</span> width, <span class="keywordtype">double</span> dpi);
00044 <span class="keywordtype">void</span> dohires(<span class="keywordtype">int</span> n0, <span class="keywordtype">int</span> msub, <span class="keywordtype">double</span> afil, <span class="keywordtype">int</span> &amp;maxf);
00045 
00046 <span class="keywordtype">void</span> filter_test(<span class="keywordtype">void</span>);
00047 
00048 <span class="keyword">inline</span> <span class="keywordtype">int</span> max0(<span class="keywordtype">int</span> a,<span class="keywordtype">int</span> b) ;
00049 <span class="keyword">inline</span> <span class="keywordtype">int</span> min0(<span class="keywordtype">int</span> a,<span class="keywordtype">int</span> b);
00050 
00051 
00052 <span class="comment">//</span>
00053 <span class="comment">// Constants</span>
00054 <span class="comment">//</span>
00055 
00056 <span class="keyword">const</span> <span class="keywordtype">int</span> MAX_PIX = 4000;
00057 <span class="keyword">const</span> <span class="keywordtype">int</span> MAX_HIRES_PIX = 30000;
00058 <span class="keyword">const</span> <span class="keywordtype">int</span> MAX_COEFFS=61;
00059 <span class="keyword">const</span> <span class="keywordtype">int</span> MAX_DERIV=101;
00060 
00061 
00062 <span class="comment">//</span>
00063 <span class="comment">// global variables; Common blocks have been converted to global</span>
00064 <span class="comment">// anonymous structs with the same name as the original block</span>
00065 <span class="comment">//</span>
00066 
00067 <span class="keyword">struct </span>{ 
00068     <span class="keywordtype">double</span> re[MAX_COEFFS][MAX_COEFFS];
00069     <span class="keywordtype">double</span> im[MAX_COEFFS][MAX_COEFFS];
00070     <span class="keywordtype">double</span> enumb[MAX_COEFFS][MAX_COEFFS]; 
00071 } Ak0;
00072 
00073 <span class="keyword">struct </span>{ 
00074     <span class="keywordtype">double</span> re[MAX_COEFFS][MAX_COEFFS];
00075     <span class="keywordtype">double</span> im[MAX_COEFFS][MAX_COEFFS];
00076 } Akf0;
00077 
00078 <span class="keyword">struct</span>{ 
00079     <span class="keywordtype">double</span> alim;
00080     <span class="keywordtype">double</span> blim;
00081 } Ab;
00082 
00083 
00084 <span class="keyword">struct </span>{
00085     <span class="keywordtype">double</span> xpact[2000]; 
00086     <span class="keywordtype">double</span> ypact[2000];
00087     <span class="keywordtype">int</span> ipact[2000]; 
00088     <span class="keywordtype">int</span> jpact[2000];
00089 } Pix;
00090 
00091 
00092 <span class="keyword">struct </span>{ 
00093     <span class="keywordtype">double</span> fij0[201][201];
00094     <span class="keywordtype">double</span> g2hkp[MAX_PIX] ;
00095 } A00;
00096 
00097 
00098 <span class="keyword">struct </span>{
00099     <span class="keywordtype">double</span> x0[MAX_DERIV][MAX_DERIV];
00100     <span class="keywordtype">double</span> xp[MAX_DERIV][MAX_DERIV];
00101     <span class="keywordtype">double</span> xm[MAX_DERIV][MAX_DERIV];   
00102 } D1H;
00103 
00104 
00105 <span class="keyword">struct </span>{
00106     <span class="keywordtype">double</span> xx0[MAX_DERIV][MAX_DERIV]; 
00107     <span class="keywordtype">double</span> xxp[MAX_DERIV][MAX_DERIV]; 
00108     <span class="keywordtype">double</span> xxm[MAX_DERIV][MAX_DERIV];
00109 } D2H;
00110 
00111 <span class="keyword">struct </span>{ 
00112     <span class="keywordtype">double</span> xhir[MAX_HIRES_PIX]; 
00113     <span class="keywordtype">double</span> yhir[MAX_HIRES_PIX]; 
00114     <span class="keywordtype">int</span> kphir;
00115 } HiR;
00116                  
00117 
00118 <span class="keyword">struct  </span>{
00119     <span class="keywordtype">double</span> f[MAX_HIRES_PIX];
00120     <span class="keywordtype">double</span> x[MAX_HIRES_PIX]; 
00121     <span class="keywordtype">double</span> y[MAX_HIRES_PIX];
00122     <span class="keywordtype">int</span> k;
00123 } Foto;
00124 
00125 
00126 <span class="keywordtype">double</span> Co[2000], Si[2000];
00127 <span class="keywordtype">int</span> Npix=0;
00128 <span class="keywordtype">int</span> N0=0, N1=0, N23=0, N13=0;
00129 <span class="keywordtype">double</span> Delx=0, Dely=0;
00130 <span class="keywordtype">double</span> *Xpix,*Ypix;
00131 <span class="keywordtype">double</span> Ypix_shift[MAX_PIX];
00132 <span class="keywordtype">double</span> Yshift;
00133 <span class="keywordtype">double</span> Dpix;
00134 <span class="keywordtype">int</span> Maxf;
00135 
00136 
00137 
00138 <span class="keyword">namespace </span>FilterParam {
00139     <span class="keyword">static</span> <span class="keywordtype">int</span> nc;
00140     <span class="keyword">static</span> <span class="keywordtype">double</span> afiltr;
00141     <span class="keyword">static</span> <span class="keywordtype">int</span> msub;
00142     <span class="keyword">static</span> <span class="keywordtype">double</span> spas;
00143 } ;
00144 
00145 <span class="keyword">namespace </span>FilterInit {
00146     <span class="keywordtype">double</span> xcoords[MAX_PIX];
00147     <span class="keywordtype">double</span> ycoords[MAX_PIX];
00148     <span class="keywordtype">double</span> im[MAX_PIX];
00149 };
00150 
00151 
00152 <span class="comment">// int main(int argc, char** argv) {</span>
00153 <span class="comment">//     filter_test();</span>
00154 <span class="comment">// }</span>
00155 
00156 
00160 <span class="keywordtype">void</span> 
00161 filter_test() {
00162 
00163     <span class="keywordflow">try</span> {
00164 
00165         <span class="comment">// ===========================================================</span>
00166         <span class="comment">// load the camera coordinates: </span>
00167         <span class="comment">// TODO: use the Camera object eventually</span>
00168 
00169         
00170         <span class="comment">// these are numbered from 0, and later via a pointer trick</span>
00171         <span class="comment">// turned into fotran-style arrays:</span>
00172         valarray&lt;double&gt; coordx(MAX_PIX); 
00173         valarray&lt;double&gt; coordy(MAX_PIX);
00174         <span class="keywordtype">double</span> x,y;
00175         <span class="keywordtype">int</span> i,npix;
00176 
00177 
00178         <span class="comment">// ===========================================================</span>
00179         <span class="comment">// Load the camera coordinates:</span>
00180 
00181         i=0;
00182         ifstream camxfile(<span class="stringliteral">"coordx.txt"</span>);
00183         <span class="keywordflow">while</span> (camxfile &amp;&amp; camxfile &gt;&gt; x){
00184             coordx[i++] = x;
00185         }
00186         camxfile.close();
00187 
00188         npix = i;
00189 
00190         i=0;
00191         ifstream camyfile(<span class="stringliteral">"coordy.txt"</span>);
00192         <span class="keywordflow">while</span> (camyfile &amp;&amp; camyfile &gt;&gt; y ){
00193             coordy[i++]= y;
00194         }
00195         camyfile.close();
00196 
00197         <span class="keywordflow">if</span> (npix != i) {
00198             cout &lt;&lt; <span class="stringliteral">"Error: size of coordx != size of coordy!"</span> &lt;&lt; endl;
00199             exit(1);
00200         }
00201         cout &lt;&lt; <span class="stringliteral">"Loaded "</span>&lt;&lt;npix&lt;&lt;<span class="stringliteral">" camera coordinates"</span>&lt;&lt;endl;
00202         
00203         <span class="comment">// ===========================================================</span>
00204         <span class="comment">// Load the image:</span>
00205 
00206 
00207         valarray&lt;double&gt; image(npix);
00208 
00209         i=0;
00210         ifstream imagefile(<span class="stringliteral">"image.txt"</span>);
00211         <span class="keywordflow">while</span> ( imagefile &amp;&amp; imagefile &gt;&gt; x){
00212             image[i++]=x;
00213         }
00214         imagefile.close();
00215 
00216 
00217         ofstream outfile(<span class="stringliteral">"debug_image.txt"</span>);
00218         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;npix; i++) {
00219             outfile &lt;&lt; setw(16) &lt;&lt; coordx[i]
00220                     &lt;&lt; setw(16) &lt;&lt; coordy[i]
00221                     &lt;&lt; setw(16) &lt;&lt; image[i]
00222                     &lt;&lt; endl;
00223         }
00224         outfile.close();
00225 
00226         cout &lt;&lt; <span class="stringliteral">"Loaded "</span>&lt;&lt;i&lt;&lt; <span class="stringliteral">" image points "</span>&lt;&lt; endl;
00227 
00228         <span class="comment">// ===========================================================</span>
00229         <span class="comment">// Filter</span>
00230 
00231         cout &lt;&lt; <span class="stringliteral">"Filtering... "</span> &lt;&lt; endl;
00232 
00233         valarray&lt;double&gt; hxc,hyc;
00234         valarray&lt;double&gt; fimage(image.size());
00235 
00236         filter_init( npix, coordx, coordy, hxc,hyc, 3,0.25,2,0.0 );
00237         filter_image( image,fimage );
00238 
00239         cout &lt;&lt; <span class="stringliteral">"Done."</span>&lt;&lt;endl;
00240 
00241 
00242         <span class="comment">// ===========================================================</span>
00243         <span class="comment">// output the smoothed image</span>
00244 
00245         <span class="comment">// at this point, the Foto.{x,y,f} arrays have been generated,</span>
00246         <span class="comment">// providing the x/y coordinate of each point in the image and</span>
00247         <span class="comment">// the signal.</span>
00248 
00249         cout &lt;&lt; <span class="stringliteral">"DEBUG: writing out "</span>&lt;&lt;Foto.k&lt;&lt;<span class="stringliteral">" points"</span>&lt;&lt;endl;
00250         ofstream smfile(<span class="stringliteral">"debug_smoothed.txt"</span>);
00251         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;=Foto.k; i++) {
00252             smfile  &lt;&lt; setw(16) &lt;&lt; Foto.x[i]
00253                     &lt;&lt; setw(16) &lt;&lt; Foto.y[i]
00254                     &lt;&lt; setw(16) &lt;&lt; Foto.f[i]
00255                     &lt;&lt; endl;
00256         }
00257         smfile.close();
00258 
00259         cout &lt;&lt; <span class="stringliteral">"DEBUG: "</span>  &lt;&lt;endl
00260              &lt;&lt; <span class="stringliteral">" size of: hxc="</span>&lt;&lt; hxc.size() &lt;&lt;endl
00261              &lt;&lt; <span class="stringliteral">" size of: hyc="</span>&lt;&lt; hyc.size() &lt;&lt;endl
00262              &lt;&lt; <span class="stringliteral">" size of: fimage="</span>&lt;&lt; fimage.size() &lt;&lt;endl;
00263         cout.flush();
00264 
00265         cout &lt;&lt; <span class="stringliteral">"DEBUG: "</span>  &lt;&lt;endl
00266              &lt;&lt; <span class="stringliteral">" max: hxc="</span>&lt;&lt; hxc.max() &lt;&lt;endl
00267              &lt;&lt; <span class="stringliteral">" max: hyc="</span>&lt;&lt; hyc.max() &lt;&lt;endl
00268              &lt;&lt; <span class="stringliteral">" max: fimage="</span>&lt;&lt; fimage.max() &lt;&lt;endl;
00269         cout &lt;&lt;<span class="stringliteral">"DEBUG: xc,yc from 0: "</span>&lt;&lt; endl;
00270         <span class="keywordflow">for</span> (i=0; i&lt;10; i++) {
00271             cout &lt;&lt;i &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; hxc[i] &lt;&lt; <span class="stringliteral">" , "</span> &lt;&lt; hyc[i]&lt;&lt;endl;
00272         }
00273         
00274     }
00275     <span class="keywordflow">catch</span> (runtime_error &amp;e) {
00276         cout &lt;&lt; <span class="stringliteral">"RuntimeError: "</span>&lt;&lt;e.what()&lt;&lt;endl;
00277     }
00278     <span class="keywordflow">catch</span>(...) {
00279         cout &lt;&lt; <span class="stringliteral">"Caught unknown exception."</span> &lt;&lt; endl;
00280     }
00281 
00282 }
00283 
00284 
00293 <span class="keywordtype">void</span> filter_init( <span class="keywordtype">int</span> npix, valarray&lt;double&gt; &amp;xc, valarray&lt;double&gt; &amp;yc,
00294                   valarray&lt;double&gt; &amp;newxc, valarray&lt;double&gt; &amp;newyc,
00295                   <span class="keywordtype">int</span> msub, <span class="keywordtype">double</span> afiltr, <span class="keywordtype">int</span> nc, <span class="keywordtype">double</span> spas ) {
00296     
00297     
00298     <span class="comment">// first copy the valarrays into regular arrays:</span>
00299     
00300     <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=0; i&lt; npix; i++) {
00301         FilterInit::xcoords[i] = xc[i];
00302         FilterInit::ycoords[i] = yc[i];
00303     }
00304 
00305     <span class="comment">// initialize:</span>
00306     
00307     hcut_init( npix, FilterInit::xcoords, FilterInit::ycoords,
00308                msub, afiltr, nc, spas );
00309 
00310 
00311     <span class="comment">// now put the hires-camera into the "new" variables:</span>
00312     
00313     newxc.resize( HiR.kphir );
00314     newyc.resize( HiR.kphir );
00315 
00316     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;HiR.kphir; i++) {
00317         
00318         newxc[i] = HiR.xhir[i+1]; <span class="comment">// note HiR is fortran-indexed</span>
00319         newyc[i] = HiR.yhir[i+1] - Yshift;
00320 
00321     }
00322 
00323     cout &lt;&lt; <span class="stringliteral">"DEBUG: image filter initialized"</span> &lt;&lt;endl;
00324 
00325 };
00326 
00335 <span class="keywordtype">double</span> filter_image(  valarray&lt;double&gt; &amp;im, valarray&lt;double&gt; &amp;newim ) {
00336         
00337     <span class="comment">// put the image into a standard array:</span>
00338 
00339     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;im.size(); i++) {
00340         FilterInit::im[i] = im[i];
00341     }
00342     
00343     <span class="comment">// filter the image:</span>
00344 
00345     hcut( FilterInit::im );
00346     
00347     <span class="keywordflow">if</span> (newim.size() != Foto.k) newim.resize(Foto.k);
00348     
00349     <span class="comment">// Copy the new image into newim </span>
00350 
00351     <span class="comment">// TODO: eventually should just convert everything to valarrays so</span>
00352     <span class="comment">// this doesn't need to happen.  For now, though, the fastest way</span>
00353     <span class="comment">// to put this into a valarray is using a copy constructor.  i</span>
00354     <span class="comment">// measured this to be approximately 200% faster than using a</span>
00355     <span class="comment">// for-loop.</span>
00356 
00357     newim = valarray&lt;double&gt;(&amp;Foto.f[1],Foto.k);
00358 
00359     <span class="keywordflow">return</span> Foto.f[Maxf];
00360 
00361 }
00362 
00363 
00364 
00365 <span class="keywordtype">void</span> hcut_init( <span class="keywordtype">int</span> npix, <span class="keywordtype">double</span> *xpix_c,  <span class="keywordtype">double</span> *ypix_c, 
00366                 <span class="keywordtype">int</span> msub, <span class="keywordtype">double</span> afiltr, <span class="keywordtype">int</span> nc, <span class="keywordtype">double</span> spas) {
00367 
00368     cout &lt;&lt; <span class="stringliteral">"DEBUG: hcut: npix="</span>&lt;&lt;npix&lt;&lt;endl;;
00369 
00370     FilterParam::afiltr = afiltr;
00371     FilterParam::msub= msub;
00372     FilterParam::nc = nc;
00373     FilterParam::spas = spas; <span class="comment">//    Spas - the "amplitude" in the filtr</span>
00374 
00375     Npix = npix;
00376     Xpix = xpix_c-1;        <span class="comment">// pointer hack to allow fortran numbering</span>
00377     Ypix = ypix_c-1;        <span class="comment">// pointer hack to allow fortran numbering</span>
00378 
00379     <span class="keyword">const</span> <span class="keywordtype">double</span> sq32=sqrt(3.)/2.;
00380     <span class="keyword">const</span> <span class="keywordtype">double</span> sq3=sqrt(3.);
00381     
00382     <span class="keywordtype">int</span> nring=11;  
00383     N0=3*(nring+1);     <span class="comment">// number of intervals along each</span>
00384                             <span class="comment">// side of the ffsu3</span>
00385     N1=N0+1;
00386     <span class="keywordtype">int</span> npix_check=N0*nring+1;
00387 
00388     <span class="keywordflow">if</span> (npix != npix_check) {
00389         cout &lt;&lt; <span class="stringliteral">"npix="</span>&lt;&lt;npix&lt;&lt;<span class="stringliteral">" !=  npix_check="</span>&lt;&lt;npix_check;
00390         <span class="comment">//      throw runtime_error("hcut: wrong number of pixels in camera");</span>
00391     }
00392 
00393     <span class="keywordflow">if</span> (npix &gt; MAX_PIX) {
00394         cout &lt;&lt; <span class="stringliteral">"Too many pixels (npix &gt; "</span>&lt;&lt; MAX_PIX&lt;&lt;<span class="stringliteral">")"</span>&lt;&lt;endl;
00395         <span class="keywordflow">throw</span> runtime_error(<span class="stringliteral">"hcut: number of pixels out of bounds"</span>);
00396     }
00397 
00398 
00399 
00400 
00401 
00402     <span class="comment">// pixel size in degrees (assumes pixels 1 is adjacent to pixel 2)</span>
00403         
00404     Dpix = sqrt(pow(Xpix[2]-Xpix[1],2)+pow(Ypix[2]-Ypix[1],2));
00405     cout &lt;&lt; <span class="stringliteral">"DEBUG: Dpix="</span>&lt;&lt;Dpix&lt;&lt;endl;
00406 
00407 
00408     Ab.blim= (<span class="keywordtype">float</span>)N0*Dpix/2.;
00409     Ab.alim=-Ab.blim;
00410 
00411     <span class="keywordtype">double</span> ba=(Ab.blim-Ab.alim);
00412     Yshift=ba/sq3;
00413 
00414     Delx=Dpix;
00415     Dely=Delx*sq32;
00416     N23=2*N0/3;
00417     N13=N0/3;
00418     
00419     <span class="keywordtype">int</span> i,j,i1,j1;
00420 
00421 
00422     <span class="comment">// shift the camera so that 0,0 corresponds with the bottom of the triangle</span>
00423 
00424 
00425     <span class="keywordflow">for</span> (i=1; i&lt;=Npix; i++) {
00426         Ypix_shift[i] = Ypix[i] + Yshift;
00427     }
00428 
00429     <span class="keywordtype">int</span> n0hir=N0*FilterParam::msub;
00430     <span class="keywordtype">int</span> n1hir=n0hir+1; <span class="comment">//  the number of POINTS along the side of</span>
00431                           <span class="comment">//  the triangle</span>
00432 
00433     <span class="keywordtype">double</span> dxhir=Delx/(<span class="keywordtype">double</span>)FilterParam::msub;
00434     <span class="keywordtype">double</span> dyhir=Dely/(<span class="keywordtype">double</span>)FilterParam::msub;
00435     <span class="keywordtype">int</span> m13=N13*FilterParam::msub;
00436     <span class="keywordtype">int</span> m23=N23*FilterParam::msub;
00437 
00438 <span class="comment">//    HiR.Kphir - number of pixels in the possibly active region, - hexagonal camera</span>
00439 <span class="comment">//    here the coordinates are prepared for further computation</span>
00440 
00441     <span class="keywordtype">int</span> jmax;
00442 
00443     <span class="keywordflow">for</span> (i1=1; i1&lt;=n1hir; i1++) {
00444         i=i1-1;
00445         jmax=n1hir-i;
00446 
00447         <span class="keywordflow">for</span>( j1=1; j1&lt;=jmax; j1++) {
00448             j=j1-1;
00449             <span class="keywordflow">if</span>(i+j &lt; m13) <span class="keywordflow">continue</span>;
00450             <span class="keywordflow">if</span>(i &gt; m23+1) <span class="keywordflow">continue</span>;
00451             <span class="keywordflow">if</span>(j &gt; m23+1) <span class="keywordflow">continue</span>;
00452             HiR.kphir++;
00453             HiR.xhir[HiR.kphir] =0.5*dxhir*(<span class="keywordtype">float</span>)(i-j);
00454             HiR.yhir[HiR.kphir] = dyhir*(<span class="keywordtype">float</span>)(i+j);
00455         }
00456     }
00457 
00458 
00459     <span class="keywordtype">int</span> n61=6*N0+1;
00460     <span class="keywordtype">double</span> del=2.0*M_PI/(<span class="keywordtype">float</span>)(6*N0);
00461     <span class="keywordtype">double</span> x0=0.0;
00462     Co[1]=1.0;
00463     Si[1]=0.0;
00464     <span class="keywordflow">for</span>(i=2; i&lt;=n61; i++) {
00465         x0=del*(<span class="keywordtype">float</span>)(i-1);
00466         Co[i]=cos(x0);
00467         Si[i]=sin(x0);
00468         <span class="keywordflow">if</span>(fabs(Co[i])&lt;3.e-7) Co[i]=0.;
00469         <span class="keywordflow">if</span>(fabs(Si[i])&lt;3.e-7) Si[i]=0. ;
00470     }
00471 
00472 }
00473 
00474 
00475 
00476         
00493 <span class="keywordtype">void</span> hcut(  <span class="keywordtype">double</span> *gpix_c ) {
00494     
00495     <span class="keywordtype">double</span> *gpix = gpix_c-1; <span class="comment">// hack to allow fortran numbering</span>
00496 
00497     <span class="comment">// done with prep</span>
00498     <span class="comment">//--------------------</span>
00499 
00500 
00501     <span class="comment">//    int imn=0;</span>
00502     <span class="comment">//    int nsig;</span>
00503     <span class="keywordtype">int</span> kpact=0;
00504     <span class="keywordtype">double</span> xij,yij;
00505     <span class="keywordtype">double</span> xr2,yr2,rr;
00506     
00507     <span class="keywordtype">int</span> i,i1,j1,ip;
00508     
00509     <span class="keywordflow">for</span> (i=1;i&lt;=Npix;i++) {
00510         A00.g2hkp[i]=0.;
00511     }
00512         
00513     <span class="comment">//    filling/cleaning the arrays, and redistribution of one-D image</span>
00514     <span class="comment">//    data, GPIX(I) into 2D- data on the grid, ENUMB(I,J)</span>
00515     
00516     <span class="keywordtype">int</span> j,jmax;
00517 
00518     <span class="keywordflow">for</span> (i1=1; i1&lt;=N1; i1++) {
00519         i=i1-1;
00520         jmax=N1-i;
00521         
00522         <span class="keywordflow">for</span> (j1=1;j1&lt;=N1;j1++) {
00523             j=j1-1;
00524 <span class="comment">//          xij=0.5*Delx*(float)(i-j);</span>
00525 <span class="comment">//          yij=Dely*(float)(i+j);</span>
00526             
00527             
00528             A00.fij0[i1][j1]=0.;
00529             Ak0.enumb[i1][j1]=0.;
00530             D1H.x0[i1][j1]=0.;
00531             D1H.xp[i1][j1]=0.;
00532             D1H.xm[i1][j1]=0.;
00533             D2H.xx0[i1][j1]=0.;
00534             D2H.xxp[i1][j1]=0.;
00535             D2H.xxm[i1][j1]=0.;
00536             
00537             <span class="keywordflow">if</span>(i &gt;= N23 || j &gt;= N23) <span class="keywordflow">continue</span>;
00538             <span class="keywordflow">if</span>((i+j) &lt; N13) <span class="keywordflow">continue</span>;
00539 
00540             xij=0.5*Delx*(<span class="keywordtype">float</span>)(i-j);
00541             yij=Dely*(<span class="keywordtype">float</span>)(i+j);
00542 
00543 <span class="comment">//          cout &lt;&lt; "DEBUG: deplx="&lt;&lt;Delx</span>
00544 <span class="comment">//               &lt;&lt; " Dely="&lt;&lt;setw(6) &lt;&lt;Dely </span>
00545 <span class="comment">//               &lt;&lt; " Dpix="&lt;&lt;setw(6) &lt;&lt;Dpix </span>
00546 <span class="comment">//               &lt;&lt; " xij="&lt;&lt;setw(6) &lt;&lt;xij</span>
00547 <span class="comment">//               &lt;&lt; " yij="&lt;&lt;setw(6) &lt;&lt;yij</span>
00548 <span class="comment">//               &lt;&lt;" 0.2*Dpix="&lt;&lt;setw(6) &lt;&lt;0.2*Dpix</span>
00549 <span class="comment">//               &lt;&lt; " npix= "&lt;&lt; npix</span>
00550 <span class="comment">//               &lt;&lt; endl;</span>
00551 
00552             <span class="keywordflow">for</span>(ip=1;ip&lt;=Npix;ip++) {
00553                 xr2=pow( (Xpix[ip]-xij),2) ;
00554                 yr2=pow( (Ypix_shift[ip]-yij),2);
00555                 rr=sqrt(xr2+yr2); 
00556 
00557 <span class="comment">//              cout &lt;&lt; "DEBUG: xpix= "&lt;&lt; setw(6) &lt;&lt; xpix[ip]</span>
00558 <span class="comment">//                   &lt;&lt; " Ypix="&lt;&lt; setw(6) &lt;&lt; Ypix[ip] </span>
00559 <span class="comment">//                   &lt;&lt; " rr="&lt;&lt; setw(6) &lt;&lt; rr</span>
00560 <span class="comment">//                   &lt;&lt; " gpix="&lt;&lt; setw(6) &lt;&lt; gpix[ip]</span>
00561 <span class="comment">//                   &lt;&lt; endl;</span>
00562 
00563 
00564                 <span class="keywordflow">if</span>(rr &gt;= 0.2*Dpix) <span class="keywordflow">continue</span>; 
00565                 Ak0.enumb[i1][j1]=gpix[ip];
00566                 
00567                 <span class="keywordflow">if</span>(gpix[ip] &lt; 0.1) <span class="keywordflow">break</span>; 
00568 
00569                 kpact++;
00570                 <span class="keywordflow">if</span>(kpact &gt;= 2000) 
00571                     cout &lt;&lt; <span class="stringliteral">"Large  Kpact="</span>&lt;&lt;kpact&lt;&lt;endl;
00572                                 Pix.xpact[kpact]=Xpix[ip];
00573                 Pix.ypact[kpact]=Ypix_shift[ip];
00574                 Pix.ipact[kpact]=i1;
00575                 Pix.jpact[kpact]=j1;
00576             } <span class="comment">//75</span>
00577 
00578         } <span class="comment">// 73</span>
00579     } <span class="comment">//74</span>
00580     
00581 
00582 
00583 <span class="comment">//    If(Nsig.GT.100) Print*,'I EAS=',ImN,'  KpAct=',KPACT,Nsig</span>
00584 
00585 
00586 <span class="comment">//    assigning initial values to Fij0: Fij0=0 on the boundary;</span>
00587          
00588     <span class="keywordtype">double</span> cf0=5./36.;
00589     <span class="keywordtype">double</span> s6;
00590     <span class="keywordtype">int</span> ij,k;
00591 
00592     <span class="keywordflow">for</span> (k=1; k&lt;=kpact; k++) {
00593         i1 = Pix.ipact[k];
00594         j1 = Pix.jpact[k];
00595         ij=i1+j1-2;
00596         <span class="keywordflow">if</span> (i1 &gt;= 1 || j1==1 || ij == N0) <span class="keywordflow">continue</span>;
00597         s6 = Ak0.enumb[i1+1][j1-1]+Ak0.enumb[i1-1][j1+1]+Ak0.enumb[i1][j1+1];
00598         s6 = s6+Ak0.enumb[i1][j1-1]+Ak0.enumb[i1+1][j1]+Ak0.enumb[i1-1][j1];
00599         A00.g2hkp[k]=s6/6. - Ak0.enumb[i1][j1];
00600         A00.fij0[i1][j1] = Ak0.enumb[i1][j1] - cf0*A00.g2hkp[k];
00601     }
00602 
00603 
00604 <span class="comment">//    Calculations of the coefficients Akl </span>
00605 
00606 <span class="comment">//    double cf2=5./54.;</span>
00607     <span class="keywordtype">double</span> cf3=5./36.;       
00608     <span class="comment">//    double f0max=0;</span>
00609     <span class="keywordtype">int</span> ic;
00610     <span class="keywordtype">int</span> k0re, k0im;
00611     <span class="keywordtype">int</span> ibig, jbig;
00612     <span class="keywordtype">double</span> hwd=0.25;   
00613 
00614     <span class="keywordflow">for</span> ( ic= 1; ic&lt;= FilterParam::nc; ic++ ){ <span class="comment">// iterate nc times for accuracy</span>
00615 
00616         doakl0(N0,A00.fij0,k0re,k0im);
00617         derivs(N0,kpact,hwd,Dpix);
00618 
00619         <span class="keywordflow">for</span>( k=1; k&lt;=kpact; k++) {
00620             ibig=Pix.ipact[k];
00621             jbig=Pix.jpact[k];
00622             i1=2*ibig-1;
00623             j1=2*jbig-1;
00624             A00.fij0[ibig][jbig]=Ak0.enumb[ibig][jbig]-cf3*A00.g2hkp[k];
00625         }
00626 
00627     }
00628 
00629 <span class="comment">//    calculation of the transform coefficients A_{kl}</span>
00630 
00631     doakl0(N0,A00.fij0,k0re,k0im)   ;
00632 
00633 <span class="comment">//    filtering-smoothing the coefficients that can be later used in the</span>
00634 <span class="comment">//    program F0Pass(,,) for computation of HiR image values, below it</span>
00635 <span class="comment">//    is computed with F0SU3NUL , corresponding to sharp cuttof</span>
00636 <span class="comment">//    filtering only.</span>
00637 
00638     dofltr0(FilterParam::spas,N0, FilterParam::afiltr);
00639 
00640 <span class="comment">//    This block sends the initial grid parameters and the filterinf</span>
00641 <span class="comment">//    parameter Afiltr, and yealds the high resolution image values 1D</span>
00642 <span class="comment">//    array, Ffoto(), and the corresponding coordinates of active pixels</span>
00643 <span class="comment">//    only</span>
00644 
00645 <span class="comment">//    Maxf - is the number of the pixel corresponding to the maximum of</span>
00646 <span class="comment">//    the new image; the maximum of the new image corresponds to</span>
00647 <span class="comment">//    Ffoto(Maxf); this falue can be fuirther used for %-cuts</span>
00648 
00649     dohires(N0,FilterParam::msub,FilterParam::afiltr, Maxf);
00650 
00651 
00652     <span class="comment">// Now, we need to shift the y-coordinates back to the original position:</span>
00653 
00654     <span class="keywordflow">for</span> (i=1; i&lt;=Foto.k; i++) {
00655         Foto.y[i] -= Yshift;
00656     }
00657 
00658 
00659 <span class="comment">//    =============================================</span>
00660 
00661 
00662 } 
00663 
00664 
00665 
00666 
00667 <span class="keywordtype">double</span> dinv(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> l ){ 
00668 
00669     <span class="comment">//    cout &lt;&lt; "DEBUG: in dinv() "&lt;&lt; endl;</span>
00670 
00671     <span class="keywordflow">if</span> (n == 0 ) <span class="keywordflow">return</span> 0;
00672     <span class="keywordflow">if</span> ( (k+l) &gt; n) <span class="keywordflow">return</span> 0;
00673     
00674     <span class="keywordtype">int</span> mk=k/n;
00675     <span class="keywordtype">int</span> ml=l/n;
00676     <span class="keywordtype">int</span> mkl=(k+l)/n;
00677     <span class="keywordtype">int</span> k0=k-n*mk;
00678     <span class="keywordtype">int</span> l0=l-ml*n;
00679     <span class="keywordtype">int</span> kl0=k+l-mkl*n;
00680     <span class="keywordtype">double</span> cl=0.;
00681     <span class="keywordtype">double</span> ck=0.;
00682     <span class="keywordtype">double</span> ckl=0.;
00683    
00684     <span class="keywordflow">if</span>(l0==0) cl=1.;
00685     <span class="keywordflow">if</span>(k0==0) ck=1.;
00686     <span class="keywordflow">if</span>(kl0==0) ckl=1.;
00687     <span class="keywordflow">return</span> 1./((1.+ckl)*(1.+ck+cl));
00688 }
00689 
00690 
00691 <span class="keywordtype">double</span> f0su3nul(<span class="keywordtype">double</span> xin, <span class="keywordtype">double</span> yin, <span class="keywordtype">int</span> n, <span class="keywordtype">double</span> af) {
00692 <span class="comment">//      COMMON/AB/ Alim, Blim</span>
00693 <span class="comment">//      COMMON/AK0/ AKLRE0(61,61),AKLIM0(61,61),ENUMB(61,61)</span>
00694     <span class="keywordtype">double</span> coy[501], cox[501], six[501];
00695 
00696 
00697     <span class="keywordtype">double</span> p2=M_PI*2.0;
00698     <span class="keywordtype">int</span> nn=n+1;
00699     <span class="keywordtype">double</span> rn=(<span class="keywordtype">double</span>)n;
00700     <span class="keywordtype">int</span> ncut= (<span class="keywordtype">int</span>)(rn * (1.- af));
00701     <span class="keywordtype">int</span> nc1=ncut+1;
00702     <span class="keywordtype">double</span> del=Ab.blim-Ab.alim;
00703     <span class="keywordtype">double</span> cen=(Ab.blim+Ab.alim)/2.;
00704     <span class="keywordtype">double</span> x0=(xin-cen)/del;
00705     <span class="keywordtype">double</span> y0=yin/del;
00706     <span class="keywordtype">double</span> sq3=sqrt(3.);
00707     <span class="keywordtype">double</span>  ysq3=y0/sq3;
00708 
00709     <span class="keywordflow">if</span>(fabs(x0) &gt;= ysq3) <span class="keywordflow">return</span> 0;
00710     <span class="keywordflow">if</span>(y0&gt;=sq3/2.) <span class="keywordflow">return</span> 0;
00711 
00712     <span class="keywordtype">int</span> ir=(<span class="keywordtype">int</span>)(rn*(x0+ysq3));
00713     <span class="keywordtype">int</span> jr=(<span class="keywordtype">int</span>)(rn*(ysq3-x0));
00714     <span class="keywordtype">int</span> i1=max0(ir+1,2);
00715     <span class="keywordtype">int</span> j1=max0(jr+1,2);
00716     <span class="keywordtype">double</span> x,y;
00717     <span class="keywordtype">int</span> i,j;
00718     <span class="keywordtype">double</span> s14;
00719     <span class="keywordtype">int</span> m1,m2,n2;
00720     <span class="keywordtype">double</span> xi,yi;
00721 
00722 <span class="comment">//     int imn2=max0(ir-2,1);</span>
00723 <span class="comment">//     int jmn2=max0(jr-2,1);</span>
00724 <span class="comment">//     int ipl2=min0(i1+1,nn);</span>
00725 <span class="comment">//     int jpl2=min0(j1+1,nn);</span>
00726 <span class="comment">//     int ipl3=min0(ir+3,nn);</span>
00727 <span class="comment">//     int jpl3=min0(jr+3,nn);</span>
00728 <span class="comment">//     int imn1=max0(ir-1,1);</span>
00729 <span class="comment">//     int jmn1=max0(jr-1,1);</span>
00730 <span class="comment">//     s14 = Ak0.enumb[ipl2][jmn2] + </span>
00731 <span class="comment">//      Ak0.enumb[imn2][jpl2] +</span>
00732 <span class="comment">//      Ak0.enumb[imn1][jpl3];</span>
00733 <span class="comment">//     s14+=Ak0.enumb[ipl3][jmn1];</span>
00734     
00735     <span class="comment">// enable or disable this?:</span>
00736     <span class="comment">//    s14=-Ak0.enumb[i1-1][j1-1]-Ak0.enumb[i1+2][j1+2];</span>
00737 
00738 
00739 <span class="comment">//     for (m1=1; m1&lt;=4; m1++) {</span>
00740 <span class="comment">//      for( m2=1; m2&lt;=4; m2++) {</span>
00741 <span class="comment">//             s14 += Ak0.enumb[i1-2+m1][j1-2+m2];</span>
00742 <span class="comment">//      }</span>
00743 <span class="comment">//     }</span>
00744 <span class="comment">//     if(s14&lt;1.e-4) return 0;</span>
00745 
00746     x=p2*x0/3.;
00747     y=p2*y0/sqrt(3.0);
00748     n2=nn+n;
00749     xi=0.;
00750     cox[1]=1.000;
00751     six[1]=0.0;
00752     <span class="keywordflow">for</span>(i=2; i&lt;=n2; i++) {
00753         xi=xi+x;
00754         cox[i]=cos(xi);
00755         six[i]=sin(xi);
00756     }
00757     yi=0.;
00758     coy[1]=2.0;
00759 
00760     <span class="keywordflow">for</span> (j=2; j&lt;=nn; j++) {
00761         yi=yi+y;
00762         coy[j]=2.*cos(yi);
00763     }
00764 
00765     <span class="keywordtype">double</span> s0=0.;
00766     <span class="keywordtype">int</span> nhalf=1+n/2;
00767     <span class="keywordtype">double</span> fr;
00768     <span class="keywordtype">int</span> k1,k0;
00769 
00770     <span class="keywordflow">for</span> (k1=1;k1&lt;=nhalf; k1++) {
00771         k0=k1-1;
00772         <span class="keywordflow">if</span>(2*k0&gt;ncut) <span class="keywordflow">continue</span>;
00773         fr=coy[k0+k1]+2.*coy[k1]*cox[3*k0+1];
00774         s0=s0+fr*Ak0.re[k1][k1];
00775     }
00776 
00777     <span class="keywordtype">double</span> s1=0.;
00778     <span class="keywordtype">int</span> l0,l1,lm;
00779     <span class="keywordtype">int</span> kml, k2l, kpl, l2k;
00780     <span class="keywordtype">double</span> fi;
00781 
00782     <span class="keywordflow">for</span> (k1=2; k1&lt;=nc1; k1++) {
00783         k0=k1-1;
00784         lm=min0(nn-k0,k0)       ;
00785         
00786         <span class="keywordflow">for</span>(l1=1;l1&lt;=lm; l1++) {
00787             l0=l1-1;
00788             <span class="keywordflow">if</span>((k0+l0)&gt;ncut) <span class="keywordflow">break</span>;
00789             kml=k1-l1+1;
00790             k2l=2*k0+l1;
00791             l2k=2*l0+k1;
00792             kpl=k0+l1;
00793             fr=coy[kpl]*cox[kml]+coy[l1]*cox[k2l]+coy[k1]*cox[l2k];
00794             fi=coy[kpl]*six[kml]-coy[l1]*six[k2l]+coy[k1]*six[l2k];    
00795             s1=Ak0.re[k1][l1]*fr - Ak0.im[k1][l1]*fi + s1;
00796         }
00797     }
00798 
00799     <span class="keywordflow">return</span> s0 + 2.*s1;
00800 }
00801 
00802 
00803 
00804 <span class="keywordtype">void</span> dofltr0(<span class="keywordtype">double</span> s, <span class="keywordtype">int</span> n0, <span class="keywordtype">double</span> afil) {
00805 <span class="comment">//       COMMON/AKF0/ AFRE0(61,61),AFIM0(61,61)</span>
00806 <span class="comment">//       COMMON/AK0/ AKLRE0(61,61),AKLIM0(61,61),AKL.ENUMB0[61,61)</span>
00807 
00808     <span class="keywordtype">int</span> n1=n0+1;
00809     <span class="keywordtype">int</span> npas=(<span class="keywordtype">int</span>)((<span class="keywordtype">float</span>)(n0)*(1.-afil));
00810     <span class="keywordtype">int</span> lpha=10;
00811 
00812     <span class="keywordtype">int</span> i,i1,j1;
00813     <span class="keywordtype">int</span> iharm, jmax;
00814     <span class="keywordtype">double</span> r;
00815 
00816     <span class="keywordflow">for</span> (i1=1;i1&lt;=n1; i1++) {
00817         i=i1-1;
00818         jmax=n1-i;
00819         <span class="keywordflow">for</span>(j1=1;j1&lt;=jmax; j1++) {
00820             iharm=i+j1-1;
00821             r=1.-s*pow((<span class="keywordtype">float</span>)(iharm)/(<span class="keywordtype">float</span>)(npas), lpha);
00822             <span class="keywordflow">if</span>(r&lt;0.) r=0.;
00823             Akf0.re[i1][j1]=Ak0.re[i1][j1]*r;
00824             Akf0.im[i1][j1]=Ak0.im[i1][j1]*r;
00825         }
00826     }
00827 
00828 }
00829 
00830 
00831 <span class="keywordtype">double</span> f0pass(<span class="keywordtype">double</span> xin, <span class="keywordtype">double</span> yin, <span class="keywordtype">int</span> n, <span class="keywordtype">double</span> afil ) {
00832 <span class="comment">//       COMMON/AB/ Alim, Blim</span>
00833 <span class="comment">//       COMMON/AKF0/ AFRE0(61,61),AFIM0(61,61)</span>
00834 <span class="comment">//       COMMON/AK0/ AKLRE0(61,61),AKLIM0(61,61),AKL.ENUMB0[61,61)</span>
00835 
00836 <span class="comment">//    cout &lt;&lt; "DEBUG: in f0pass() "&lt;&lt; endl;</span>
00837 
00838     <span class="keywordtype">double</span> coy[501], cox[501], six[501];
00839     <span class="keywordtype">double</span> p2=M_PI*2.0;
00840     <span class="keywordtype">int</span> nn=n+1;
00841     <span class="keywordtype">int</span> nmax=(<span class="keywordtype">int</span>)((<span class="keywordtype">float</span>)(n)*(1.-afil));
00842     <span class="keywordtype">int</span> nc1=nmax+1;
00843     <span class="keywordtype">double</span> del=Ab.blim-Ab.alim;
00844     <span class="keywordtype">double</span> cen=(Ab.blim+Ab.alim)/2.;
00845     <span class="keywordtype">double</span>     x0=(xin-cen)/del;
00846     <span class="keywordtype">double</span> y0=yin/del;
00847     <span class="keywordtype">double</span> sq3=sqrt(3.);
00848     <span class="keywordtype">double</span> ysq3=y0/sq3;
00849     <span class="keywordflow">if</span>(fabs(x0)&gt;=ysq3)  <span class="keywordflow">return</span> 0;
00850     <span class="keywordflow">if</span>(y0&gt;=sq3/2.) <span class="keywordflow">return</span> 0;
00851 
00852     <span class="keywordtype">double</span> rn=(<span class="keywordtype">double</span>)(n);
00853     <span class="keywordtype">int</span> ir=(<span class="keywordtype">int</span>)(rn*(x0+ysq3));
00854     <span class="keywordtype">int</span> jr=(<span class="keywordtype">int</span>)(rn*(ysq3-x0));
00855     <span class="keywordtype">int</span> i1=max0(ir+1,2);
00856     <span class="keywordtype">int</span> j1=max0(jr+1,2);
00857     <span class="keywordtype">int</span> imn2=max0(ir-2,1);
00858     <span class="keywordtype">int</span> jmn2=max0(jr-2,1);
00859     <span class="keywordtype">int</span> ipl2=min0(i1+1,nn);
00860     <span class="keywordtype">int</span> jpl2=min0(j1+1,nn);
00861     <span class="keywordtype">int</span> ipl3=min0(ir+3,nn);
00862     <span class="keywordtype">int</span> jpl3=min0(jr+3,nn);
00863     <span class="keywordtype">int</span> imn1=max0(ir-1,1);
00864     <span class="keywordtype">int</span> jmn1=max0(jr-1,1);
00865     <span class="keywordtype">double</span> s14=Ak0.enumb[ipl2][jmn2]
00866         + Ak0.enumb[imn2][jpl2]
00867         + Ak0.enumb[imn1][jpl3];
00868 
00869     s14 += Ak0.enumb[ipl3][jmn1]+s14;
00870 <span class="comment">//    S14=-Ak0.enumb[I1-1][J1-1]-Ak0.enumb[I1+2][J1+2]</span>
00871 
00872     <span class="keywordtype">int</span> m1,m2;
00873 
00874     <span class="keywordflow">for</span> (m1=1;m1&lt;=4;m1++) {
00875         <span class="keywordflow">for</span> (m2=1;m2&lt;=4;m2++) {
00876             s14 += Ak0.enumb[i1-2+m1][j1-2+m2];
00877         }
00878     }
00879     <span class="keywordflow">if</span>(s14&lt;1.e-4) <span class="keywordflow">return</span> 0;
00880 
00881 <span class="comment">//    IPJ=Int(RN*2.*Ysq3)-IR-JR</span>
00882 <span class="comment">//    S3ang=Ak0.enumb0[I1][J1+1]+Ak0.enumb0[I1+1][J1]+Ak0.enumb0[I1+IPJ][J1+IPJ]</span>
00883 <span class="comment">//    IF(S3ang&lt;1.e-4) Return</span>
00884 
00885     
00886 
00887     <span class="keywordtype">double</span> x=p2*x0/3.;
00888     <span class="keywordtype">double</span> y=p2*y0/1.7320508;
00889     <span class="keywordtype">int</span> n2=nn+n;
00890     <span class="keywordtype">double</span> xi=0.;
00891     <span class="keywordtype">int</span> i;
00892 
00893     cox[1]=1.000;
00894     six[1]=0.0;
00895     <span class="keywordflow">for</span>(i=2;i&lt;=n2; i++) {
00896         xi=xi+x;
00897         cox[i]=cos(xi);
00898         six[i]=sin(xi);
00899     }
00900     
00901     <span class="keywordtype">double</span> yi=0.;
00902     <span class="keywordtype">int</span> j;
00903 
00904     coy[1]=2.0;
00905     <span class="keywordflow">for</span> (j=2; j&lt;nn; j++) {
00906         yi=yi+y;
00907         coy[j]=2.*cos(yi);
00908     }
00909 
00910     <span class="keywordtype">double</span> s0=0.;
00911     <span class="keywordtype">int</span>  nhalf=1+n/2;
00912     <span class="keywordtype">int</span> k1,k0;
00913     <span class="keywordtype">double</span> fr;
00914 
00915     <span class="keywordflow">for</span> ( k1=1;k1&lt;=nhalf; k1++) {
00916         k0=k1-1;
00917         <span class="keywordflow">if</span>(2*k0&gt;nmax) <span class="keywordflow">continue</span>;
00918         fr=coy[k0+k1]+2.*coy[k1]*cox[3*k0+1];
00919         s0=s0+fr*Akf0.re[k1][k1];
00920     }
00921 
00922    <span class="keywordtype">double</span>  s1=0.;
00923    <span class="keywordtype">int</span> l1,lm,l0,kml,k2l,l2k,kpl;
00924    <span class="keywordtype">double</span> fi;
00925    
00926    <span class="keywordflow">for</span>( k1=2; k1&lt;=nn ;k1++) {
00927        k0=k1-1;
00928        lm=min0(nc1-k0,k0) ;
00929        <span class="keywordflow">for</span>(l1=1;l1&lt;=lm;l1++) {
00930            l0=l1-1;
00931            <span class="keywordflow">if</span>(l0+k0&gt;nmax) <span class="keywordflow">break</span>;
00932            kml=k1-l1+1;
00933            k2l=2*k0+l1;
00934            l2k=2*l0+k1;
00935            kpl=k0+l1;
00936            fr=coy[kpl]*cox[kml]+coy[l1]*cox[k2l]+coy[k1]*cox[l2k];
00937            fi=coy[kpl]*six[kml]-coy[l1]*six[k2l]+coy[k1]*six[l2k];
00938            s1=Akf0.re[k1][l1]*fr - Akf0.im[k1][l1]*fi + s1;
00939        }
00940    }
00941 
00942    <span class="keywordflow">return</span> s0+2.*s1;
00943 
00944 }
00945 
00946 
00947 
00948 <span class="keywordtype">void</span> doakl0(<span class="keywordtype">int</span> nn0, <span class="keywordtype">double</span> tfij[][201], <span class="keywordtype">int</span> &amp;k0re, <span class="keywordtype">int</span> &amp;k0im) {
00949 
00950     <span class="keywordtype">double</span> fdij[121][121];
00951     <span class="keywordtype">double</span> tdkl[121][121] ;
00952 <span class="comment">//       COMMON/AK0/ AKLRE0(61,61),AKLIM0(61,61),AKL.ENUMB0[61,61)</span>
00953 
00954     <span class="keywordtype">int</span> n0=nn0;
00955     <span class="keywordtype">int</span> n1=n0+1;
00956     k0re=0;
00957     k0im=0;
00958 
00959     <span class="keywordflow">if</span>(n1&gt;MAX_COEFFS) cout &lt;&lt; <span class="stringliteral">"ERROR: Insufficient space"</span>&lt;&lt;endl;
00960     <span class="keywordtype">int</span> n6=6*n0 ;
00961     <span class="keywordtype">int</span> nhalf=1+n0/2;
00962 
00963     <span class="keywordtype">int</span> i1,j1,lm,i,j;
00964 
00965     <span class="keywordflow">for</span> ( i1=1; i1&lt;=n1; i1++) {
00966         i=i1-1;
00967         lm=n1-i;
00968         <span class="keywordflow">for</span> (j1=1;j1&lt;=lm;j1++) {
00969             j=j1-1;
00970             tdkl[i1][j1]=dinv(n0,i,j);
00971             fdij[i1][j1]=2.*tfij[i1][j1]*tdkl[i1][j1];
00972         }
00973     }
00974 
00975 
00976     <span class="keywordtype">double</span> cn=1./(<span class="keywordtype">float</span>)(3*n0*n0);
00977     <span class="keywordtype">int</span> k1, k, kipj,kplipj,k2limj,m1,m2,m3,m4,m5,m6;
00978     <span class="keywordtype">double</span> sre, sim,fr;
00979     <span class="keywordtype">int</span> ipj,imj,is;
00980 
00981     <span class="keywordflow">for</span> (k1=1;k1&lt;=nhalf;k1++){
00982         k=k1-1;
00983         sre=0.;
00984         sim=0.;
00985         <span class="keywordflow">for</span>(i1=1; i1&lt;=n1; i1++) {
00986             i=i1-1;
00987             lm=n1-i;
00988             <span class="keywordflow">for</span>(j1=1;j1&lt;=lm; j1++) {
00989                 <span class="keywordflow">if</span>(fabs(fdij[i1][j1])&lt;1.e-7) <span class="keywordflow">continue</span>;
00990                 j=j1-1;
00991                 ipj=i+j;
00992                 imj=i-j;
00993                 is=1;
00994                 <span class="keywordflow">if</span>(i&lt;j) is=-1;
00995                 kipj=3*k*ipj;
00996                 kplipj=(kipj+kipj);
00997                 k2limj=(2*k+k)*imj*is;
00998                 m1=kplipj-n6*(kplipj/n6) +1;
00999                 m2=kipj-n6*(kipj/n6) +1;
01000                 m3=k2limj-n6*(k2limj/n6) +1;
01001                 fr=Co[m1]+2.*Co[m2]*Co[m3];
01002                 sre=sre+fr*fdij[i1][j1];
01003             }
01004         }
01005         Ak0.re[k1][k1]=cn*sre*tdkl[k1][k1];
01006         Ak0.im[k1][k1]=0.0;
01007         <span class="keywordflow">if</span>(fabs(Ak0.re[k1][k1])&lt;1.e-6) k0re=k0re+1;
01008         k0im=k0im+1;
01009     }
01010 
01011     <span class="keywordtype">int</span> lmax,l1,l,jm,kpl,k2l,l2k,kml,lipj;
01012     <span class="keywordtype">double</span> fi;
01013 
01014     <span class="keywordflow">for</span>( k1=2;k1&lt;=n1;k1++ ) {
01015         k=k1-1;
01016         lmax=min0(n1-k,k);
01017         <span class="keywordflow">for</span> ( l1=1;l1&lt;=lmax;l1++) {
01018             l=l1-1;
01019             sre=0.;
01020             sim=0.;
01021             <span class="keywordflow">for</span>( i1=1;i1&lt;=n1; i1++) {
01022                 i=i1-1;
01023                 jm=n1-i;
01024                 <span class="keywordflow">for</span> ( j1=1;j1&lt;=jm; j1++) {
01025                     <span class="keywordflow">if</span>(fabs(fdij[i1][j1])&lt;1.e-7) <span class="keywordflow">continue</span>;
01026                     j=j1-1;
01027                     ipj=i+j;
01028                     is=1;
01029                     <span class="keywordflow">if</span>(i&lt;j) is=-1;
01030                     imj=(i-j)*is;
01031                     kipj=3*k*ipj;
01032                     lipj=3*l*ipj;
01033                     kpl=kipj+lipj;
01034                     k2l=(2*k+l)*imj;
01035                     l2k=(2*l+k)*imj;
01036                     kml=k2l-l2k;
01037                   
01038                     m1=kpl-n6*(kpl/n6)+1;
01039                     m2=kipj-n6*(kipj/n6)+1;
01040                     m3=lipj-n6*(lipj/n6)+1;
01041                     m5=k2l-n6*(k2l/n6)+1;
01042                     m6=l2k-n6*(l2k/n6)+1;
01043                     m4=kml-n6*(kml/n6)+1;
01044 
01045                     fr=Co[m1]*Co[m4]+Co[m3]*Co[m5]+Co[m2]*Co[m6];
01046                     fi=(Co[m1]*Si[m4]-
01047                         Co[m3]*Si[m5]+Co[m2]*Si[m6])*(<span class="keywordtype">float</span>)(is);
01048                     sre=sre+fr*fdij[i1][j1];
01049                     sim=sim+fi*fdij[i1][j1];
01050                 }
01051             }
01052             Ak0.re[k1][l1]=cn*sre*tdkl[k1][l1];
01053             Ak0.im[k1][l1]=-cn*sim*tdkl[k1][l1];
01054             Ak0.re[l1][k1]=Ak0.re[k1][l1];
01055             Ak0.im[l1][k1]=-Ak0.im[k1][l1];
01056             <span class="keywordflow">if</span>(fabs(Ak0.re[k1][l1])&lt;1.e-6) k0re=k0re+2;
01057             <span class="keywordflow">if</span>(fabs(Ak0.im[k1][l1])&lt;1.e-6) k0im=k0im+2;
01058         }
01059     }
01060 
01061 <span class="comment">//     cout &lt;&lt; "DEBUG: coefficients: ";</span>
01062 <span class="comment">//     for ( i=1; i&lt;=n1; i++) {</span>
01063 <span class="comment">//      cout &lt;&lt; i &lt;&lt; ":" &lt;&lt; Ak0.re[i][1] &lt;&lt; endl;</span>
01064 <span class="comment">//     }</span>
01065 
01066 }
01067       
01068 <span class="comment">//    calculation of the coordinates of the triangles in the hexagon</span>
01069 <span class="comment">//    devided into 6 K^2 triangles;    </span>
01070 <span class="comment">//    </span>
01071 
01072 
01073 <span class="keywordtype">void</span> derivs(<span class="keywordtype">int</span> n,<span class="keywordtype">int</span> kp,<span class="keywordtype">double</span> width, <span class="keywordtype">double</span> dpi) {
01074 <span class="comment">//       COMMON/PIX/ XpAct(2000),YpAct(2000),IpAct(2000),JpAct(2000)</span>
01075 <span class="comment">//       COMMON/D2H/ D2HXX0(101,101),D2HXXP(101,101),D2HXXM(101,101)</span>
01076 <span class="comment">//       COMMON/A00/  FIJ0(201,201),A00.G2hkp(MAX_PIX)</span>
01077 <span class="comment">//       COMMON/D1H/ D1HX0(101,101),D1HXP(101,101),D1HXM(101,101)</span>
01078 
01079         
01080     <span class="keywordtype">int</span> n0=n;
01081     <span class="comment">//int l0=2*n;</span>
01082     <span class="keywordtype">double</span> h0=dpi/2.;
01083     <span class="keywordtype">double</span> dx=h0*width;
01084     <span class="keywordtype">double</span> amp1=1./width/2.;
01085     <span class="keywordtype">double</span> amp2= pow((1./width),2);
01086     <span class="keywordtype">double</span> dy=sqrt(3.)*dx/2.;
01087     <span class="keywordtype">double</span> c23=2./3.;
01088     <span class="keywordtype">int</span> i,j,k;
01089     <span class="keywordtype">double</span> x0,y0;
01090     <span class="keywordtype">double</span> f1,f2,f3,f4,f5,f6,f02;
01091     
01092     <span class="keywordflow">for</span> (k=1; k&lt;=kp;k++) {
01093         i=Pix.ipact[k];
01094         j=Pix.jpact[k];
01095         x0=Pix.xpact[k];
01096         y0=Pix.ypact[k];
01097         f02 = 2. * f0su3nul(x0,y0,n0,0.);
01098         
01099         f1=f0su3nul(x0+dx,y0,n0,0.);
01100         f2=f0su3nul(x0+dx/2.,y0+dy,n0,0.);
01101         f3=f0su3nul(x0-dx/2.,y0+dy,n0,0.);
01102         f4=f0su3nul(x0-dx,y0,n0,0.);
01103         f5=f0su3nul(x0-dx/2.,y0-dy,n0,0.);
01104         f6=f0su3nul(x0+dx/2.,y0-dy,n0,0.);
01105         
01106         
01107         D1H.x0[i][j]=(f1-f4)*amp1;
01108         D1H.xp[i][j]=(f2-f5)*amp1;
01109         D1H.xm[i][j]=(f6-f3)*amp1;
01110         D2H.xx0[i][j]=amp2*(f1+f4-f02);
01111         D2H.xxp[i][j]=amp2*(f2+f5-f02);
01112         D2H.xxm[i][j]=amp2*(f3+f6-f02);
01113         A00.g2hkp[k]=c23*(D2H.xx0[i][j]+D2H.xxp[i][j]+D2H.xxm[i][j]);
01114     }
01115     
01116 }
01117 
01118 
01119 
01120 <span class="keywordtype">void</span> dohires(<span class="keywordtype">int</span> n0, <span class="keywordtype">int</span> msub, <span class="keywordtype">double</span> afil, <span class="keywordtype">int</span> &amp;Maxf) {
01121 <span class="comment">//       Common/HiR/ XHiR(30000),YHiR(30000),KpHiR</span>
01122 <span class="comment">//       Common/Foto/ Ffoto(30000),Xfoto(30000),Yfoto(30000),Kfoto</span>
01123 
01124     <span class="keywordtype">double</span>  ffmax=0.;
01125     <span class="comment">//    int n0hir=n0*msub;</span>
01126     <span class="keywordtype">int</span> k;
01127     <span class="keywordtype">double</span> xi,yi,gn;
01128 
01129     Foto.k=0;
01130     Maxf=0;
01131 
01132 
01133     <span class="keywordflow">for</span> (k=1; k&lt;=HiR.kphir; k++) {
01134         xi=HiR.xhir[k];
01135         yi=HiR.yhir[k];
01136         gn=f0su3nul(xi,yi,n0,afil);
01137         <span class="comment">//      gn=f0pass(xi,yi,n0,afil);</span>
01138 <span class="comment">//      if(gn &lt;= 1.e-5) continue; // kpk removed this so we get the whole thing</span>
01139        
01140         Foto.k++;
01141         Foto.f[Foto.k]=gn;
01142         Foto.x[Foto.k]=xi;
01143         Foto.y[Foto.k]=yi;
01144 
01145         <span class="keywordflow">if</span>(gn&gt;ffmax){
01146             ffmax=gn;
01147             Maxf=Foto.k;
01148         }
01149     }
01150     
01151 
01152 
01153 }
01154 
01155 
01156 
01160 <span class="keywordtype">int</span> max0(<span class="keywordtype">int</span> a,<span class="keywordtype">int</span> b) {
01161     <span class="keywordflow">return</span> (a&gt;=b)? a:b;
01162 }
01163 
01167 <span class="keywordtype">int</span> min0(<span class="keywordtype">int</span> a,<span class="keywordtype">int</span> b) {
01168     <span class="keywordflow">return</span> (a&lt;=b)?a:b;
01169 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Apr 21 10:22:45 2007 for wuparam by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
