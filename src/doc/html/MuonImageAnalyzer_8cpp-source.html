<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>wuparam: MuonImageAnalyzer.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>MuonImageAnalyzer.cpp</h1><div class="fragment"><pre>00001 <span class="comment">//</span>
00002 <span class="comment">// MuonImageAnalyzer.cpp  - ImageAnalyzer for looking for muon rings</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// Jim Buckley &lt;buckley@wuphys.wustl.edu&gt;</span>
00005 <span class="comment">// Karl Kosack &lt;kosack@hbar.wustl.edu&gt;</span>
00006 <span class="comment">//</span>
00007 
00008 <span class="preprocessor">#include &lt;cmath&gt;</span>
00009 <span class="preprocessor">#include &lt;vector&gt;</span>
00010 <span class="preprocessor">#include &lt;iostream&gt;</span>
00011 <span class="preprocessor">#include &lt;iomanip&gt;</span>
00012 <span class="preprocessor">#include &lt;valarray&gt;</span>
00013 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00014 <span class="preprocessor">#include &lt;gsl/gsl_sf_trig.h&gt;</span>
00015 <span class="preprocessor">#include &lt;gsl/gsl_math.h&gt;</span>
00016 
00017 <span class="preprocessor">#include "Camera.h"</span>
00018 <span class="preprocessor">#include "Exceptions.h"</span>
00019 <span class="preprocessor">#include "Types.h"</span>
00020 <span class="preprocessor">#include "ImageAnalyzer.h"</span>
00021 <span class="preprocessor">#include "MuonImageAnalyzer.h"</span>
00022 <span class="preprocessor">#include "Image2D.h"</span>
00023 <span class="preprocessor">#include "PlotMaker.h"</span>
00024 <span class="preprocessor">#include "Histogram.h"</span>
00025 
00026 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00027 
<a name="l00031"></a><a class="code" href="classMuonImageAnalyzer.html#a0">00031</a> <a class="code" href="classMuonImageAnalyzer.html#a0">MuonImageAnalyzer::MuonImageAnalyzer</a>( <a class="code" href="classCamera.html">Camera</a> *cam )
00032     : <a class="code" href="classImageAnalyzer.html">ImageAnalyzer</a>(cam), _plot_points_is_enabled(false), 
00033       _calibration_is_enabled(true)
00034 {
00035 
00036     <span class="keyword">register</span> <span class="keywordtype">int</span> i,j;
00037 
00038 
00039     <span class="comment">//    pm = new PlotMaker( "X","x.out" );</span>
00040 
00041 
00042     <span class="comment">// Set the sizes of all the lookup tables and grids</span>
00043 
00044     _single_pmt_mask.resize(getNumPixels()) ;
00045     
00046 <span class="comment">//     cout &lt;&lt; "DEBUG: resizing centers to "&lt;&lt; getNumPixels() &lt;&lt; "^3 size="</span>
00047 <span class="comment">//       &lt;&lt; pow((double)getNumPixels(),3)*sizeof(Triplet) </span>
00048 <span class="comment">//       &lt;&lt; " sizeof triplet is "&lt;&lt; sizeof(Triplet)</span>
00049 <span class="comment">//       &lt;&lt; endl;</span>
00050 
00051 <span class="comment">//     _centers.resize(getNumPixels()) ;   // Allocate the 3d centers array </span>
00052 <span class="comment">//     for(i=0;i&lt;getNumPixels();i++) {</span>
00053 <span class="comment">//      _centers[i].resize(getNumPixels()) ;</span>
00054 <span class="comment">//      for(j=0;j&lt;getNumPixels();j++) {</span>
00055 <span class="comment">//             _centers[i][j].resize(getNumPixels()) ;</span>
00056 <span class="comment">//      }</span>
00057 <span class="comment">//     }</span>
00058     
00059 
00060     _pmtmask.resize(NX) ;   <span class="comment">// Now initalize all of the arrays that </span>
00061     _ntrip.resize(NX) ;     <span class="comment">// cover the NX x NY 2-d grid covering </span>
00062     _xsum.resize(NX) ;      <span class="comment">// the camera.                         </span>
00063     _ysum.resize(NX) ;
00064     _rsum.resize(NX) ;
00065     
00066     <span class="keywordflow">for</span>(i=0;i&lt;NX;i++) {
00067         _pmtmask[i].resize(NY) ;
00068         _ntrip[i].resize(NY) ;
00069         _xsum[i].resize(NY) ;
00070         _ysum[i].resize(NY) ;
00071         _rsum[i].resize(NY) ;
00072         <span class="keywordflow">for</span>(j=0;j&lt;NY;j++) {
00073             _pmtmask[i][j].resize(_nwords = getNumPixels()/<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)) ;
00074         }
00075     }
00076         
00077     <span class="comment">// Initialize a structure containing the bitmask for each PMT.</span>
00078     <span class="comment">// Since there are a large number of PMTs in the camera, divide</span>
00079     <span class="comment">// the mask up into a number of 32 bit words</span>
00080      
00081     <span class="keywordflow">for</span>(i=0; i&lt;getNumPixels(); i++) {
00082         _single_pmt_mask[i].word = i/<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) ;
00083         _single_pmt_mask[i].bit = 0x00000001 &lt;&lt; (i % <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)) ;
00084     }
00085     
00086     <span class="comment">// Loop through the N*(N-1)*(N-2)/(3*2*1) triplets, where N=nadc</span>
00087     <span class="comment">// vals and calculate the (x,y) coordinate of the ring center for</span>
00088     <span class="comment">// each triplet, the index (ix,iy) of the ring-center grid and the</span>
00089     <span class="comment">// radius r of the ring defined by these three points.</span>
00090 
00091 <span class="comment">//     int i1,i2,i3;</span>
00092     
00093 <span class="comment">//     for(i1=0; i1&lt;getNumPixels(); i1++) {</span>
00094 <span class="comment">//      for(i2=i1+1; i2&lt;getNumPixels(); i2++) {</span>
00095 <span class="comment">//             for(i3=i2+1; i3&lt;getNumPixels(); i3++) {</span>
00096 
00097 <span class="comment">//              getCenter( i1,i2,i3, _centers[i1][i2][i3] );</span>
00098                 
00099 <span class="comment">//             } // end for i3 </span>
00100 <span class="comment">//      } // end for i2 </span>
00101 <span class="comment">//     } // end for i1 </span>
00102     
00103 
00104 }
00105 
00109 <span class="keyword">inline</span> <span class="keywordtype">void</span> 
00110 MuonImageAnalyzer::
00111 getCenter( <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2, <span class="keywordtype">int</span> i3, Triplet &amp; t ) {
00112 
00113     <span class="keywordtype">double</span> denom, numx, numy;
00114     <span class="keywordtype">double</span> x0,y0,x1,y1,x2,y2,x3,y3;
00115     <span class="keywordtype">double</span>  x1sq,y1sq,x2sq,y2sq,x3sq,y3sq ;
00116     <span class="keywordtype">double</span> rsq;
00117 
00118     x1 = _x[i1] ; x2 = _x[i2] ; x3 = _x[i3] ;
00119     y1 = _y[i1] ; y2 = _y[i2] ; y3 = _y[i3] ;
00120     
00121     x1sq = _x2[i1] ; x2sq = _x2[i2] ; x3sq = _x2[i3] ;
00122     y1sq = _y2[i1] ; y2sq = _y2[i2] ; y3sq = _y2[i3] ;
00123     
00124     denom = 2.0*((x2-x3)*(y1-y2)-(x1-x2)*(y2-y3)) ;
00125     
00126     t.ix = t.iy = -1;
00127 
00128     <span class="keywordflow">if</span>(fabs(denom) &gt; 1.0e-10) {
00129         numx = ((x2sq-x3sq+y2sq-y3sq)*(y1-y2)
00130                 -(x1sq-x2sq+y1sq-y2sq)*(y2-y3)) ;
00131         x0 = numx/denom ;
00132         t.ix = static_cast&lt;short&gt;(NXD2 + floor(x0/DX));
00133         
00134         <span class="keywordflow">if</span>((t.ix &gt; 0)&amp;&amp;(t.ix &lt;= NX)) {
00135             numy = ((x1sq-x2sq+y1sq-y2sq)*(x2-x3)
00136                     -(x2sq-x3sq+y2sq-y3sq)*(x1-x2)) ;
00137             y0 = numy/denom ;
00138             t.iy = static_cast&lt;short&gt;(NYD2 + floor(y0/DY));
00139             
00140             <span class="keywordflow">if</span>((t.iy &gt; 0)&amp;&amp;(t.iy &lt;= NY)) {
00141                 rsq = (x1-x0)*(x1-x0)+(y1-y0)*(y1-y0) ;
00142                 <span class="keywordflow">if</span>((rsq &gt; 0.0)&amp;&amp;(rsq &lt; RSQMAX)) {
00143                     t.x0 = x0 ;
00144                     t.y0 = y0 ;
00145                     t.r = sqrt(rsq) ;
00146                 } <span class="comment">// end if rsq </span>
00147                 <span class="keywordflow">else</span> { 
00148                     <span class="comment">// Flag that value is out of range </span>
00149                     t.ix = -1 ;
00150                     t.iy = -1 ;
00151                 }
00152             } <span class="comment">//end if iy </span>
00153             <span class="keywordflow">else</span> {
00154                 t.iy = -1 ;
00155                 t.ix = -1 ;
00156             }
00157         } <span class="comment">// end if ix </span>
00158         <span class="keywordflow">else</span> {
00159             t.ix = -1 ;
00160             t.iy = -1;
00161         }
00162     } <span class="comment">// end if denom </span>
00163 
00164     
00165 }
00166 
00167 
00168 
00175 <span class="keywordtype">void</span> 
00176 <a class="code" href="classMuonImageAnalyzer.html#a2">MuonImageAnalyzer::</a>
<a name="l00177"></a><a class="code" href="classMuonImageAnalyzer.html#a2">00177</a> <a class="code" href="classMuonImageAnalyzer.html#a2">parameterize</a>( <span class="keyword">const</span> Array_t &amp;image, std::vector&lt;int&gt; &amp;cleanpixels ){
00178 
00179     <span class="keywordtype">int</span> i,j,k,i1,i2,i3,n,ix,iy;
00180     <span class="keywordtype">int</span> nbox;
00181     <span class="keywordtype">int</span> ixmax,iymax,nmax ;
00182     <span class="keywordtype">double</span> dnmax;
00183     <span class="keywordtype">double</span> phsum;
00184     <span class="keywordtype">int</span> nph;
00185     vector&lt;unsigned int&gt; totpmtmask ;
00186     <span class="keywordtype">double</span> dxa, dya, stot, sarc;
00187     <span class="keywordtype">double</span> wsum, wphi, wphisq, wt, phi;
00188     <span class="keywordtype">double</span> wt_sum;
00189     <span class="keywordtype">double</span> ringfrac1, ringfrac2;
00190     <span class="keywordtype">double</span> xcs, ycs, dphi;
00191     <span class="keywordtype">double</span> size_clean, size_raw;
00192     <span class="keywordtype">int</span> npix, narc;
00193     <span class="keywordtype">int</span> npict;
00194     <span class="keywordtype">int</span> word1, word2, word3, tubenum1, tubenum2, tubenum3;
00195     <span class="keywordtype">int</span> tubenum, wordnum;
00196     Triplet center;
00197 
00198     string str;
00199     <a class="code" href="classHistogram.html">Histogram</a> phihist( 15, 0.0, M_PI*2.0, <span class="stringliteral">"Muon Phi"</span> );
00200 
00201     <span class="comment">// KPK: added this to calculate area of pixel.  It assumes no</span>
00202     <span class="comment">// spacing between pixels, which is fair due to the light cones.</span>
00203     <span class="comment">// (just pi * r^2)</span>
00204     <span class="keywordtype">double</span> apix =  (pow(_x[1]-_x[0],2) + pow(_y[1]-_y[0], 2))/4.0 * M_PI;
00205     
00206     npict = cleanpixels.size() ; 
00207     _mparam.<a class="code" href="structMuonParameterization.html#o13">nplotpoints</a> = 0 ;
00208 
00209     <span class="keywordflow">if</span>(npict &lt; 3) {
00210         
00211         _mparam.<a class="code" href="structMuonParameterization.html#a0">clear</a>();
00212         
00213         <span class="keywordflow">return</span> ;
00214 
00215     }
00216 
00217     totpmtmask.resize(_nwords) ;
00218 
00219     <span class="keywordflow">for</span>(i=0; i &lt; NX; i++) {
00220         <span class="keywordflow">for</span>(j=0; j &lt; NY; j++) {
00221             _ntrip[i][j] = 0 ;
00222             _xsum[i][j] = 0.0 ;
00223             _ysum[i][j] = 0.0 ;
00224             _rsum[i][j] = 0.0 ;
00225 
00226             <span class="keywordflow">for</span> (k=0; k&lt;_nwords; k++) {
00227                 _pmtmask[i][j][k] = 0;
00228             }
00229 
00230         }
00231     } 
00232     n=0 ;
00233     
00234     <span class="comment">// Loop through the N*(N-1)*(N-2)/(3*2*1) triplets, where N=npict</span>
00235     <span class="comment">// Note that cleanpixels[i] gives the pixel number of the ith</span>
00236     <span class="comment">// element of the list of picture pixels.</span>
00237 
00238     <span class="keywordtype">int</span> total_trips=0;
00239 
00240     <span class="keywordflow">for</span>(i1=0; i1 &lt; npict; i1++) {
00241         word1 = _single_pmt_mask[tubenum1=cleanpixels[i1]].word ;
00242         <span class="keywordflow">for</span>(i2=i1+1; i2 &lt; npict; i2++) {
00243             word2 = _single_pmt_mask[tubenum2=cleanpixels[i2]].word ;
00244             <span class="keywordflow">for</span>(i3=i2+1; i3 &lt; npict; i3++) {
00245                 word3 = _single_pmt_mask[tubenum3=cleanpixels[i3]].word ;
00246                 n++ ;
00247 
00248                 getCenter( tubenum1,tubenum2,tubenum3, center );
00249                 ix = static_cast&lt;int&gt;(center.ix);
00250                 iy = static_cast&lt;int&gt;(center.iy);
00251                 assert( center.ix &lt;= NX &amp;&amp; center.iy &lt;= NY );
00252 
00253 
00254                 <span class="keywordflow">if</span>((ix &gt; 0) &amp;&amp; (iy &gt; 0)) {
00255 
00256                     _ntrip[ix][iy]++ ;
00257 
00258                     total_trips++;
00259 
00260                     <span class="comment">// Accumulate averages at the appropriate bin</span>
00261                 
00262                     _rsum[ix][iy] += center.r ;
00263                     _xsum[ix][iy] += center.x0 ;
00264                     _ysum[ix][iy] += center.y0 ;
00265                 
00266                     <span class="keywordflow">if</span>(_plot_points_is_enabled) {     
00267                         <span class="comment">// Save some of the ring centers for display </span>
00268                         <span class="keywordflow">if</span>(_mparam.<a class="code" href="structMuonParameterization.html#o13">nplotpoints</a> &lt; MAX_PLOT_CENTERS) {
00269                             _mparam.<a class="code" href="structMuonParameterization.html#o12">plot</a>[_mparam.<a class="code" href="structMuonParameterization.html#o13">nplotpoints</a>].x = center.x0 ;
00270                             _mparam.<a class="code" href="structMuonParameterization.html#o12">plot</a>[_mparam.<a class="code" href="structMuonParameterization.html#o13">nplotpoints</a>].y = center.y0 ;
00271                             _mparam.<a class="code" href="structMuonParameterization.html#o13">nplotpoints</a>++ ;
00272                         } 
00273                     }
00274                 
00275                     <span class="comment">// Set the bits in pmtmask corresponding to the pmts</span>
00276                     <span class="comment">// indexed by i1,i2,i3</span>
00277                 
00278                     _pmtmask[ix][iy][word1] |= _single_pmt_mask[tubenum1].bit ;
00279                     _pmtmask[ix][iy][word2] |= _single_pmt_mask[tubenum2].bit ;
00280                     _pmtmask[ix][iy][word3] |= _single_pmt_mask[tubenum3].bit ;
00281 
00282                 } <span class="comment">// end if ix,iy in range </span>
00283             } <span class="comment">// end for i3 </span>
00284         } <span class="comment">// end for i2 </span>
00285     } <span class="comment">// end for i1 </span>
00286 
00287     <span class="comment">// First find the index of the box-car smoothed ntrip array that</span>
00288     <span class="comment">// contains the maximum number of triplet ring centers.  Note: It</span>
00289     <span class="comment">// is not a mistake that the for loop runs as long as ix &lt; NX-1 -</span>
00290     <span class="comment">// the -1 is needed because of the boxcar sum.</span>
00291 
00292     nmax = 0 ;
00293     <span class="keywordflow">for</span>(ix=0; ix &lt; NX-1; ix++) {
00294         <span class="comment">// find maximum smoothed ntrip </span>
00295         <span class="keywordflow">for</span>(iy=0; iy &lt; NY-1; iy++) { 
00296             nbox = _ntrip[ix][iy]+_ntrip[ix+1][iy]+_ntrip[ix+1][iy+1]+
00297                 _ntrip[ix][iy+1] ;
00298             <span class="keywordflow">if</span>(nbox &gt; nmax) {
00299                 nmax = nbox ;
00300                 ixmax = ix ;
00301                 iymax = iy ;
00302             } 
00303         } 
00304     } 
00305 
00306     
00307     <span class="comment">// TEST PLOT OF ntrip</span>
00308 <span class="comment">//     Image2D ntripimg(NX,NY);</span>
00309 <span class="comment">//     ntripimg.setCoordinateBox( -static_cast&lt;double&gt;(NX)/2.0*DX,</span>
00310 <span class="comment">//                             -static_cast&lt;double&gt;(NY)/2.0*DY,</span>
00311 <span class="comment">//                            static_cast&lt;double&gt;(NX)/2.0*DX,</span>
00312 <span class="comment">//                            static_cast&lt;double&gt;(NY)/2.0*DY  );</span>
00313 <span class="comment">//     for(ix=0; ix &lt; NX-1; ix++) {</span>
00314 <span class="comment">//      for(iy=0; iy &lt; NY-1; iy++) { </span>
00315 <span class="comment">//          ntripimg.setPixel( ix,iy, _ntrip[ix][iy] );</span>
00316 <span class="comment">//      }</span>
00317 <span class="comment">//     }</span>
00318 
00319 <span class="comment">//     pm-&gt;setAxisBox( ntripimg );</span>
00320 <span class="comment">//     pm-&gt;plot( ntripimg );</span>
00321 <span class="comment">//     pm-&gt;plotAxes();</span>
00322 <span class="comment">//     pm-&gt;flush();</span>
00323 <span class="comment">//     pm-&gt;newPage();</span>
00324     
00325     <span class="comment">// calculate the centroid and width/length of the triplet-space image:</span>
00326     
00327     <span class="keywordtype">double</span>  momx=0;   
00328     <span class="keywordtype">double</span>  momy=0 ;  
00329     <span class="keywordtype">double</span>  momx2=0;  
00330     <span class="keywordtype">double</span>  momy2=0 ; 
00331     <span class="keywordtype">double</span> total=0;
00332     <span class="keywordtype">double</span> twidth;
00333 
00334     <span class="keywordflow">for</span>(ix=0; ix &lt; NX-1; ix++) {
00335         <span class="keywordflow">for</span>(iy=0; iy &lt; NY-1; iy++) { 
00336             momx    += _ntrip[ix][iy] * ix;
00337             momy    += _ntrip[ix][iy] * iy;
00338             momx2   += _ntrip[ix][iy] * ix*ix;
00339             momy2   += _ntrip[ix][iy] * iy*iy;
00340             total   += _ntrip[ix][iy];
00341         }
00342     }
00343     
00344     momx  /= total;   
00345     momy  /= total;   
00346     momx2 /= total;   
00347     momy2 /= total;   
00348 
00349     <span class="keywordtype">double</span> vx2  = (momx2 - momx*momx);       <span class="comment">// &lt;x^2&gt; - &lt;x&gt;^2</span>
00350     <span class="keywordtype">double</span> vy2  = (momy2 - momy*momy);       <span class="comment">// &lt;y^2&gt; - &lt;y&gt;^2</span>
00351 
00352     twidth = sqrt( (vx2 + vy2)/2.0  );
00353  
00354     <span class="comment">// calculate the ring center</span>
00355     <span class="keywordflow">if</span>(nmax &gt; 0) {
00356         dnmax = (<span class="keywordtype">double</span>)nmax ;
00357         _mparam.<a class="code" href="structMuonParameterization.html#o1">ringcenter</a>.<a class="code" href="structCoordinate__t.html#o0">x</a> = (_xsum[ixmax][iymax]+_xsum[ixmax+1][iymax]+
00358                                 _xsum[ixmax+1][iymax+1]+
00359                                 _xsum[ixmax][iymax+1])/dnmax ;
00360         
00361         _mparam.<a class="code" href="structMuonParameterization.html#o1">ringcenter</a>.<a class="code" href="structCoordinate__t.html#o1">y</a> = (_ysum[ixmax][iymax]+_ysum[ixmax+1][iymax]+
00362                                 _ysum[ixmax+1][iymax+1]+
00363                                 _ysum[ixmax][iymax+1])/dnmax ;
00364         
00365         _mparam.<a class="code" href="structMuonParameterization.html#o0">radius</a> = (_rsum[ixmax][iymax]+_rsum[ixmax+1][iymax]+
00366                           _rsum[ixmax+1][iymax+1]+_rsum[ixmax][iymax+1])/dnmax;
00367         
00368         <span class="keywordflow">for</span>(i=0; i &lt; _nwords; i++) {
00369             totpmtmask[i]=_pmtmask[ixmax][iymax][i] |
00370                 _pmtmask[ixmax+1][iymax][i] |
00371                 _pmtmask[ixmax+1][iymax+1][i] |
00372                 _pmtmask[ixmax][iymax+1][i] ;
00373         } 
00374             
00375         phsum = 0.0 ;
00376         nph = 0 ;
00377         <span class="keywordflow">for</span>(i=0; i &lt; npict; i++) {
00378 
00379             tubenum=cleanpixels[i] ;
00380             wordnum=_single_pmt_mask[tubenum].word ;
00381                 
00382             <span class="comment">// If a tube has contributed to the arc include it's</span>
00383             <span class="comment">// pulseheight in the sum, and increment the total number</span>
00384             <span class="comment">// of tubes contributing to arc, nph.</span>
00385 
00386             <span class="keywordflow">if</span>((_single_pmt_mask[tubenum].bit &amp; totpmtmask[wordnum]) &gt; 0) {
00387                 phsum += image[tubenum] ; 
00388                 nph++ ;
00389             } 
00390 
00391 
00392         } 
00393 
00394         <span class="comment">// Calculate fraction of number of centers in the peak bin to</span>
00395         <span class="comment">// the total number of centers.</span>
00396         <span class="keywordflow">if</span>(npict &gt; 3) 
00397 <span class="comment">//          _mparam.arcstrength = 6.0*dnmax/(double)(npict*(npict-1)*(npict-2)) ;</span>
00398             _mparam.<a class="code" href="structMuonParameterization.html#o2">arcstrength</a> = dnmax / 4.0 ;
00399         <span class="keywordflow">else</span> {
00400             _mparam.<a class="code" href="structMuonParameterization.html#o2">arcstrength</a> = 0.0 ;
00401         } 
00402 
00403             
00404         <span class="keywordflow">if</span>((_mparam.<a class="code" href="structMuonParameterization.html#o0">radius</a> &gt; 0.0) &amp;&amp; (nph &gt; 0)) {
00405 
00406             <span class="comment">// Modified 961009 by JB - Acutually while the light per</span>
00407             <span class="comment">// unit pathlength is proportional to theta^2 or r^2, the</span>
00408             <span class="comment">// pathlength increases as theta^-1 or r^-1, and the light</span>
00409             <span class="comment">// per pixel is proportional to the light per azimuth</span>
00410             <span class="comment">// angle divided by r, so actually the *gain should does</span>
00411             <span class="comment">// not depend on radius to first order.</span>
00412 
00413             _mparam.<a class="code" href="structMuonParameterization.html#o3">gain</a> = phsum/(<span class="keywordtype">double</span>)(nph) ;
00414                  
00415             <span class="comment">// Added 961104 by JB - Calculate amount of light in an</span>
00416             <span class="comment">// anulus about the ring center, approx. correct for</span>
00417             <span class="comment">// fraction of area covered by pixels and for the linear</span>
00418             <span class="comment">// dependence of the total amount of light on radius.</span>
00419 
00420             <span class="keywordflow">if</span> (_calibration_is_enabled) {
00421 
00422                 <span class="comment">// CALIBRATION HERE</span>
00423 
00424 
00425                 <span class="comment">// First calculate arc angle...</span>
00426 
00427                 <span class="keywordtype">double</span> arcangle = 0.0 ;
00428                 wsum = 0.0 ;
00429                 xcs = 0.0 ;
00430                 ycs = 0.0 ;
00431                      
00432                 <span class="comment">// For all pixels in the cleaned image, see if they</span>
00433                 <span class="comment">// also contributed to the muon arc (i.e., were</span>
00434                 <span class="comment">// contained in the boxcar averaged combined bitmask</span>
00435                 <span class="comment">// for the grid position with the maximum number of</span>
00436                 <span class="comment">// ring centers).  For all such pixels that</span>
00437                 <span class="comment">// contributed to the muon arc, calculate the centroid</span>
00438                 <span class="comment">// of the light distribution relative to the ring</span>
00439                 <span class="comment">// center position.</span>
00440 
00441                 <span class="keywordflow">for</span>(i=0; i&lt;npict; i++) { 
00442                     tubenum = cleanpixels[i] ;
00443                     wordnum = _single_pmt_mask[tubenum].word ;
00444 
00445                     <span class="keywordflow">if</span>((_single_pmt_mask[tubenum].bit &amp; 
00446                         totpmtmask[wordnum]) &gt; 0) {
00447                         
00448                         dxa = _x[tubenum] - _mparam.<a class="code" href="structMuonParameterization.html#o1">ringcenter</a>.<a class="code" href="structCoordinate__t.html#o0">x</a> ;
00449                         dya = _y[tubenum] - _mparam.<a class="code" href="structMuonParameterization.html#o1">ringcenter</a>.<a class="code" href="structCoordinate__t.html#o1">y</a> ;
00450                         wt = image[tubenum] ;
00451                         wsum += wt ;
00452                         xcs += dxa*wt ;
00453                         ycs += dya*wt ;
00454                     } 
00455 
00456                 } 
00457                      
00458                 <span class="keywordflow">if</span> (wsum &gt; 0.0) {
00459                          
00460                     <span class="comment">// Calculate angle of vector from ring center to</span>
00461                     <span class="comment">// centroid of light distribution in ring</span>
00462                          
00463                     xcs /= wsum ;   
00464                     ycs /= wsum ;   
00465 
00466                     <span class="comment">// wphi = M_PI+atan2(ycs,xcs) ;</span>
00467                     
00468                     wphi = atan2(ycs,xcs) ;
00469 
00470 
00471 <span class="comment">//                  cout &lt;&lt; "DEBUG: muon: xcs="&lt;&lt;xcs</span>
00472 <span class="comment">//                       &lt;&lt; " ycs="&lt;&lt; ycs &lt;&lt; " wphi="&lt;&lt;wphi*180.0/M_PI</span>
00473 <span class="comment">//                       &lt;&lt; endl;</span>
00474 
00475                     <span class="comment">// Next calculate the length of the vector from</span>
00476                     <span class="comment">// the centroid to the ring center, and divide by</span>
00477                     <span class="comment">// the ring radius.  Define a new quantity muskew</span>
00478                     <span class="comment">// to be the ratio of the two.  Note that muskew</span>
00479                     <span class="comment">// is small for a complete ring.  This may or may</span>
00480                     <span class="comment">// not be useful</span>
00481                          
00482                     _mparam.<a class="code" href="structMuonParameterization.html#o7">muskew</a> = sqrt(xcs*xcs+ycs*ycs)/_mparam.<a class="code" href="structMuonParameterization.html#o0">radius</a> ;
00483                          
00484                     <span class="comment">// In the spirit of the Hillas moment analysis,</span>
00485                     <span class="comment">// calculate the arclength from the second moment</span>
00486                     <span class="comment">// of the angle phi distribution (the angle of a</span>
00487                     <span class="comment">// vector from the most probably ring center to</span>
00488                     <span class="comment">// each pixel contributing to the ring)</span>
00489                          
00490                     wphisq = 0.0 ;
00491                     wt_sum = 0.0;
00492                     <span class="keywordflow">for</span>(i=0; i&lt;npict; i++) { 
00493                         tubenum = cleanpixels[i] ;
00494                         wordnum = _single_pmt_mask[tubenum].word ;
00495                         <span class="keywordflow">if</span>( (_single_pmt_mask[tubenum].bit 
00496                              &amp; totpmtmask[wordnum]) &gt; 0 ) {
00497                                  
00498                             dxa = _x[tubenum] - _mparam.<a class="code" href="structMuonParameterization.html#o1">ringcenter</a>.<a class="code" href="structCoordinate__t.html#o0">x</a> ;
00499                             dya = _y[tubenum] - _mparam.<a class="code" href="structMuonParameterization.html#o1">ringcenter</a>.<a class="code" href="structCoordinate__t.html#o1">y</a> ;
00500                             <span class="comment">// phi = M_PI+atan2(dya,dxa) ;</span>
00501                             phi = atan2(dya,dxa) ;
00502                             wt = image[tubenum] ;
00503                             wt_sum += wt;
00504                             dphi = fabs(phi-wphi) ;
00505                             dphi = GSL_MIN(dphi,fabs(dphi-2*M_PI)) ;
00506                             <span class="comment">// dphi=gsl_sf_angle_restrict_pos(fabs(phi-wphi));</span>
00507                             <span class="comment">// dphi = GSL_MIN_DBL(dphi,M_PI-dphi) ; </span>
00508                             
00509                             wphisq += (wt*dphi*dphi) ;
00510                                  
00511                         } 
00512                     }  <span class="comment">// end for all pixels in the arc </span>
00513                          
00514                     arcangle = sqrt( wphisq/wt_sum ) ;
00515                     _mparam.<a class="code" href="structMuonParameterization.html#o9">philo</a> = wphi - arcangle ;
00516                     _mparam.<a class="code" href="structMuonParameterization.html#o10">phihi</a> = wphi + arcangle ;
00517                     _mparam.<a class="code" href="structMuonParameterization.html#o11">phimid</a> = wphi;
00518                     _mparam.<a class="code" href="structMuonParameterization.html#o17">xcs</a> = xcs + _mparam.<a class="code" href="structMuonParameterization.html#o1">ringcenter</a>.<a class="code" href="structCoordinate__t.html#o0">x</a>;
00519                     _mparam.<a class="code" href="structMuonParameterization.html#o18">ycs</a> = ycs + _mparam.<a class="code" href="structMuonParameterization.html#o1">ringcenter</a>.<a class="code" href="structCoordinate__t.html#o1">y</a>;
00520                     
00521                          
00522                 }
00523                 <span class="keywordflow">else</span> {  <span class="comment">// if  wsum &lt;= 0.0 </span>
00524                     wphi = 0.0 ;
00525                     _mparam.<a class="code" href="structMuonParameterization.html#o9">philo</a> = 0.0 ;
00526                     _mparam.<a class="code" href="structMuonParameterization.html#o10">phihi</a> = 0.0 ;
00527                     _mparam.<a class="code" href="structMuonParameterization.html#o11">phimid</a> =0.0 ;
00528                     arcangle = 1.0e20 ;        <span class="comment">/* CHECK THIS */</span>
00529                 } 
00530                      
00531 
00532                 <span class="comment">// calculate size</span>
00533                 
00534                 size_clean = 0.0;
00535                 <span class="keywordflow">for</span> (i=0; i&lt;npict; i++) {
00536                     size_clean += image[cleanpixels[i]];
00537                 }
00538 
00539 
00540                 <span class="comment">// =======================================================</span>
00541                 <span class="comment">// Now loop through ALL pixels, calculating the total</span>
00542                 <span class="comment">// amount of light in an annulus around the ring and</span>
00543                 <span class="comment">// attempt to correct for the fraction of light lost</span>
00544                 <span class="comment">// at the edge of the camera.  Also, we want to later</span>
00545                 <span class="comment">// determine the "smoothness" of the angular</span>
00546                 <span class="comment">// distribution of light for muon selection - for that</span>
00547                 <span class="comment">// we need to generate a "phi" histogram here. We</span>
00548                 <span class="comment">// define two annulli: FINE and COARSE, since we want</span>
00549                 <span class="comment">// a more restrictuve annulus for the "smoothness".</span>
00550                      
00551                 npix = 0 ;
00552                 narc = 0 ;
00553                 stot = 0.0 ;
00554                 sarc = 0.0 ;
00555                 size_raw = 0.0;
00556                 phihist.<a class="code" href="classHistogram.html#a22">reset</a>(); 
00557 
00558 
00559                 <span class="keywordtype">double</span> r2_coarse = _mparam.<a class="code" href="structMuonParameterization.html#o0">radius</a> + DRAD_COARSE ;
00560                 <span class="keywordtype">double</span> r1_coarse = _mparam.<a class="code" href="structMuonParameterization.html#o0">radius</a> - DRAD_COARSE ;
00561                 <span class="keywordflow">if</span> (r1_coarse &lt; 0.0) 
00562                     r1_coarse = 0.0 ;
00563                 <span class="keywordtype">double</span> r1sq_coarse = r1_coarse*r1_coarse ;
00564                 <span class="keywordtype">double</span> r2sq_coarse = r2_coarse*r2_coarse ;
00565 
00566                 <span class="keywordtype">double</span> r2_fine = _mparam.<a class="code" href="structMuonParameterization.html#o0">radius</a> + DRAD_FINE ;
00567                 <span class="keywordtype">double</span> r1_fine = _mparam.<a class="code" href="structMuonParameterization.html#o0">radius</a> - DRAD_FINE ;
00568                 <span class="keywordflow">if</span> (r1_fine &lt; 0.0) 
00569                     r1_fine = 0.0 ;
00570                 <span class="keywordtype">double</span> r1sq_fine = r1_fine*r1_fine ;
00571                 <span class="keywordtype">double</span> r2sq_fine = r2_fine*r2_fine ;
00572 
00573                 <span class="keywordtype">double</span> aanulus_coarse = M_PI*(r2sq_coarse-r1sq_coarse) ;
00574                 <span class="keywordtype">double</span> rpsq;
00575 
00576                 <span class="keywordflow">for</span>(i=0; i&lt;getNumPixels(); i++) {
00577                     size_raw += image[i];
00578                     dxa = (_x[i] - _mparam.<a class="code" href="structMuonParameterization.html#o1">ringcenter</a>.<a class="code" href="structCoordinate__t.html#o0">x</a>) ;
00579                     dya = (_y[i] - _mparam.<a class="code" href="structMuonParameterization.html#o1">ringcenter</a>.<a class="code" href="structCoordinate__t.html#o1">y</a>) ;
00580                     rpsq = dxa*dxa + dya*dya ;
00581 
00582                     <span class="comment">// If radius of point falls within the COARSE annulus:</span>
00583 
00584                     <span class="keywordflow">if</span> ((rpsq &gt; r1sq_coarse)&amp;&amp;(rpsq &lt; r2sq_coarse)) {
00585 
00586                         phi = atan2(dya,dxa) ;
00587                         dphi = fabs(phi-wphi) ;
00588                         dphi = GSL_MIN_DBL(dphi,fabs(dphi-2*M_PI)) ;
00589 
00590                         
00591                         <span class="comment">// if radius of point falls within the FINE</span>
00592                         <span class="comment">// radius, use it for the "smoothness"</span>
00593                         <span class="comment">// calculation:</span>
00594 
00595                         <span class="keywordflow">if</span> ((rpsq &gt; r1sq_fine)&amp;&amp;(rpsq &lt; r2sq_fine)) {
00596                             
00597                             <span class="comment">// accumulate the phi position,</span>
00598                             <span class="comment">// restricting angles to 0..2*PI: </span>
00599                             phihist.<a class="code" href="classHistogram.html#a4">accumulate</a>( fmod(phi+M_PI, 2.0*M_PI),
00600                                                 image[i] );
00601                         }
00602                              
00603                         <span class="comment">// Sum up the total amount of signal falling</span>
00604                         <span class="comment">// in the annulus and with an angular distance</span>
00605                         <span class="comment">// less than the arclength into one sum called</span>
00606                         <span class="comment">// sarc</span>
00607                              
00608                         <span class="keywordflow">if</span> (fabs(dphi) &lt; arcangle) {
00609                             narc++ ; 
00610                             sarc += image[i] ;
00611                         } 
00612                              
00613                         <span class="comment">// Sum up all of the signal falling in the</span>
00614                         <span class="comment">// annulus into another sum called stot</span>
00615                   
00616                         npix++ ;
00617                         stot += image[i] ;
00618                     } <span class="comment">// end if rpsq </span>
00619                 } <span class="comment">// end for i</span>
00620  
00621 
00622                 <span class="comment">// =======================================================</span>
00623                 <span class="comment">// calculate the "smoothness" of the phi histogram for</span>
00624                 <span class="comment">// muon selection.  Calculate the average difference</span>
00625                 <span class="comment">// between bins (like derivative) and the variance of</span>
00626                 <span class="comment">// that quantity.</span>
00627 
00628 
00629 <span class="comment">//              phihist.save("phihist"); // for DEBUG purposes and plotting</span>
00630 
00631                 <span class="keywordtype">double</span> delta=0;
00632                 <span class="keywordtype">double</span> deltasum=0;
00633                 <span class="keywordtype">double</span> deltasum2=0;
00634                 <span class="keywordtype">int</span> nphi =0;
00635                 <span class="keywordflow">for</span> (i=0; i&lt;phihist.<a class="code" href="classHistogram.html#a17">numBins</a>()-1; i++) {
00636 
00637                     delta = fabs(phihist[i+1] - phihist[i]);
00638                     deltasum += delta;
00639                     deltasum2 += delta*delta;
00640                     nphi++;
00641 
00642                 }
00643 
00644                 <span class="keywordtype">double</span> avg;
00645                 <span class="keywordflow">if</span> (phihist.<a class="code" href="classHistogram.html#a17">numBins</a>()&gt;0) 
00646                     avg = phihist.<a class="code" href="classHistogram.html#a12">sum</a>()/(<span class="keywordtype">double</span>)phihist.<a class="code" href="classHistogram.html#a17">numBins</a>();
00647                 <span class="keywordflow">else</span>
00648                     avg = 1;
00649                 
00650                 _mparam.<a class="code" href="structMuonParameterization.html#o15">smoothness</a> = deltasum/(<span class="keywordtype">double</span>)nphi/avg;
00651                 _mparam.<a class="code" href="structMuonParameterization.html#o16">smoothness_var</a> = sqrt(deltasum2/(<span class="keywordtype">double</span>)nphi)/avg;
00652 
00653 
00654                 <span class="comment">// =======================================================</span>
00655                 <span class="comment">// Calculate the radial spread in the image about the</span>
00656                 <span class="comment">// ring center</span>
00657 
00658                 <span class="keywordtype">double</span> rp;
00659                 <span class="keywordtype">double</span> sumsigr2=0;
00660                 <span class="keywordtype">double</span> totalsignal;
00661 
00662                 vector&lt;int&gt;::iterator pix;
00663 
00664                 <span class="keywordflow">for</span> (pix=cleanpixels.begin();pix!=cleanpixels.end();pix++) {
00665 
00666                     rp += sqrt(pow(_x[*pix] - _mparam.<a class="code" href="structMuonParameterization.html#o1">ringcenter</a>.<a class="code" href="structCoordinate__t.html#o0">x</a> ,2) +
00667                         pow(_y[*pix] - _mparam.<a class="code" href="structMuonParameterization.html#o1">ringcenter</a>.<a class="code" href="structCoordinate__t.html#o1">y</a> ,2));
00668                     
00669                     <span class="keywordflow">if</span> (rp&gt;0) {
00670 
00671                         totalsignal += image[*pix];
00672                         sumsigr2 += pow( rp - _mparam.<a class="code" href="structMuonParameterization.html#o0">radius</a>,2  )*image[*pix];
00673 
00674                     }
00675                     
00676                 }
00677 
00678                 _mparam.<a class="code" href="structMuonParameterization.html#o19">rspread</a> = sqrt(sumsigr2/totalsignal);
00679 
00680 
00681                 <span class="comment">// =======================================================</span>
00682                 <span class="comment">// define the muonness: </span>
00683                 <span class="comment">// eventually, this should include "smoothness" factor</span>
00684 
00685                 <span class="keywordflow">if</span> (_mparam.<a class="code" href="structMuonParameterization.html#o0">radius</a> &gt; SATURATION_RADIUS-0.6 
00686                     &amp;&amp; _mparam.<a class="code" href="structMuonParameterization.html#o0">radius</a> &lt; SATURATION_RADIUS+0.3) {
00687                     _mparam.<a class="code" href="structMuonParameterization.html#o14">muonness</a> = (stot&gt;0)? stot/size_raw:1e10;
00688                 }
00689                 <span class="keywordflow">else</span> {
00690                     _mparam.<a class="code" href="structMuonParameterization.html#o14">muonness</a> = 0.0;
00691                 }
00692 
00693 
00694                 <span class="comment">// =======================================================</span>
00695                 <span class="comment">// Calculate the area covered by all pixels with</span>
00696                 <span class="comment">// coordinates inside of the annulus, compared with</span>
00697                 <span class="comment">// the total area of the annulus.  The ratio</span>
00698                 <span class="comment">// (ringfrac1) determines how much of the ring image</span>
00699                 <span class="comment">// fell off of the camera.  The arclength (arclen) is</span>
00700                 <span class="comment">// also calculated here</span>
00701                 
00702                 <span class="keywordflow">if</span> (npix &gt; 0) {
00703 
00704                     <span class="keywordflow">if</span>(aanulus_coarse &gt; 1.0e-20) {
00705                         ringfrac1 = (apix * (<span class="keywordtype">double</span>)(npix))/aanulus_coarse ;
00706                         <span class="keywordflow">if</span>(ringfrac1 &gt; 1.0e-20) {
00707                             _mparam.<a class="code" href="structMuonParameterization.html#o4">mugain</a> = (1.0/36.0)*stot *
00708                                 (SATURATION_RADIUS/_mparam.<a class="code" href="structMuonParameterization.html#o0">radius</a>)/ringfrac1 ;
00709                         }
00710                         _mparam.<a class="code" href="structMuonParameterization.html#o5">ringfrac</a> = ringfrac1;
00711                     }
00712                         
00713 
00714                     _mparam.<a class="code" href="structMuonParameterization.html#o8">arclen</a> = arcangle * SATURATION_RADIUS;   <span class="comment">// temporary</span>
00715                                                                      <span class="comment">// until</span>
00716                                                                      <span class="comment">// ring</span>
00717                                                                      <span class="comment">// fit</span>
00718                                                                      <span class="comment">// works</span>
00719                                                                      <span class="comment">// better</span>
00720 <span class="comment">//                  _mparam.arclen = arcangle * _mparam.radius;</span>
00721 
00722                     <span class="comment">// NOTE: soal is defined as size over arc length.</span>
00723                     
00724                     <span class="keywordflow">if</span>(_mparam.<a class="code" href="structMuonParameterization.html#o8">arclen</a> &gt; 1.0e-20) {
00725                         
00726                         <span class="comment">// ringfrac2 is the fraction of the area in the</span>
00727                         <span class="comment">// arc from philo to phihi which falls on the</span>
00728                         <span class="comment">// camera.  Note that since dN/dphi scales</span>
00729                         <span class="comment">// like the radius, a correction for ring</span>
00730                         <span class="comment">// radius is also required.  </span>
00731 
00732                         <span class="comment">// JB 030617 - TODO: CHECK THIS - I just argued</span>
00733                         <span class="comment">// earlier that a correction for radius was</span>
00734                         <span class="comment">// not necessary.  Which is correct?</span>
00735 
00736                         <span class="comment">// KPK: TODO: ringfrac2 is calculated but never used!</span>
00737 
00738                         ringfrac2 = (apix * (<span class="keywordtype">double</span>)(narc)) / 
00739                             (GSL_MAX_DBL(1.e-20,aanulus_coarse)*
00740                              (_mparam.<a class="code" href="structMuonParameterization.html#o10">phihi</a>-_mparam.<a class="code" href="structMuonParameterization.html#o9">philo</a>)
00741                              /(2*M_PI));
00742                         _mparam.<a class="code" href="structMuonParameterization.html#o6">soal</a> = sarc/_mparam.<a class="code" href="structMuonParameterization.html#o8">arclen</a> ;
00743 
00744                     } <span class="comment">// end if arclen</span>
00745                 } <span class="comment">// end if npix </span>
00746                 <span class="keywordflow">else</span> {
00747                     _mparam.<a class="code" href="structMuonParameterization.html#o4">mugain</a> = 0.0 ;
00748                 } 
00749 
00750             } <span class="comment">// end if fcalibrate </span>
00751         } <span class="comment">// end if radius </span>
00752         <span class="keywordflow">else</span> {
00753             _mparam.<a class="code" href="structMuonParameterization.html#o3">gain</a> = 0.0 ;
00754             _mparam.<a class="code" href="structMuonParameterization.html#o4">mugain</a> = 0.0 ;
00755         } 
00756              
00757     } <span class="comment">/* end if */</span>
00758 
00759     <span class="comment">// As always, set values to some overflow which flag an ivalid</span>
00760     <span class="comment">// event</span>
00761         
00762     <span class="keywordflow">else</span> {  
00763         _mparam.<a class="code" href="structImageParameterization.html#o4">invalid</a> = 1;
00764         _mparam.<a class="code" href="structMuonParameterization.html#o1">ringcenter</a>.<a class="code" href="structCoordinate__t.html#o0">x</a> = 1000.0 ;
00765         _mparam.<a class="code" href="structMuonParameterization.html#o1">ringcenter</a>.<a class="code" href="structCoordinate__t.html#o1">y</a> = 1000.0 ;
00766         _mparam.<a class="code" href="structMuonParameterization.html#o0">radius</a> = 1000.0 ;
00767         _mparam.<a class="code" href="structMuonParameterization.html#o3">gain</a> = 1.0e10 ;
00768         _mparam.<a class="code" href="structMuonParameterization.html#o4">mugain</a> = 1.0e10 ;
00769         _mparam.<a class="code" href="structMuonParameterization.html#o2">arcstrength</a> = 0.0 ;
00770     } <span class="comment">/* end else */</span>
00771 
00772        
00773 
00774 }
00775 
00776 
00777 ostream &amp;operator&lt;&lt;( ostream &amp;stream,<span class="keyword">const</span> <a class="code" href="structMuonParameterization.html">MuonParameterization</a> &amp;p) {
00778 
00779     stream &lt;&lt; setw(10) &lt;&lt; p.<a class="code" href="structMuonParameterization.html#o0">radius</a> &lt;&lt;<span class="stringliteral">" "</span>
00780            &lt;&lt; setw(10) &lt;&lt; p.<a class="code" href="structMuonParameterization.html#o1">ringcenter</a>.<a class="code" href="structCoordinate__t.html#o0">x</a> &lt;&lt;<span class="stringliteral">" "</span>
00781            &lt;&lt; setw(10) &lt;&lt; p.<a class="code" href="structMuonParameterization.html#o1">ringcenter</a>.<a class="code" href="structCoordinate__t.html#o1">y</a> &lt;&lt;<span class="stringliteral">" "</span>
00782            &lt;&lt; setw(10) &lt;&lt; p.<a class="code" href="structMuonParameterization.html#o2">arcstrength</a> &lt;&lt;<span class="stringliteral">" "</span>
00783            &lt;&lt; setw(10) &lt;&lt; p.<a class="code" href="structMuonParameterization.html#o3">gain</a> &lt;&lt;<span class="stringliteral">" "</span>
00784            &lt;&lt; setw(10) &lt;&lt; p.<a class="code" href="structMuonParameterization.html#o4">mugain</a> &lt;&lt;<span class="stringliteral">" "</span>
00785            &lt;&lt; setw(10) &lt;&lt; p.<a class="code" href="structMuonParameterization.html#o7">muskew</a> &lt;&lt;<span class="stringliteral">" "</span>
00786            &lt;&lt; setw(10) &lt;&lt; p.<a class="code" href="structMuonParameterization.html#o5">ringfrac</a> &lt;&lt;<span class="stringliteral">" "</span>
00787            &lt;&lt; setw(10) &lt;&lt; p.<a class="code" href="structMuonParameterization.html#o6">soal</a> &lt;&lt;<span class="stringliteral">" "</span>
00788            &lt;&lt; setw(10) &lt;&lt; p.<a class="code" href="structMuonParameterization.html#o8">arclen</a>&lt;&lt;<span class="stringliteral">" "</span>
00789            &lt;&lt; setw(10) &lt;&lt; p.<a class="code" href="structMuonParameterization.html#o14">muonness</a>&lt;&lt;<span class="stringliteral">" "</span>
00790            &lt;&lt; setw(10) &lt;&lt; p.<a class="code" href="structMuonParameterization.html#o15">smoothness</a>&lt;&lt;<span class="stringliteral">" "</span>
00791            &lt;&lt; setw(10) &lt;&lt; p.<a class="code" href="structMuonParameterization.html#o16">smoothness_var</a> &lt;&lt;<span class="stringliteral">" "</span>
00792            &lt;&lt; setw(10) &lt;&lt; p.<a class="code" href="structMuonParameterization.html#o19">rspread</a> &lt;&lt;<span class="stringliteral">" "</span>
00793         ;
00794 
00795     <span class="keywordflow">return</span> stream;
00796 
00797 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Apr 21 10:22:45 2007 for wuparam by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
